9.1 纹理与资源的回顾
2D纹理是一种由特定数据元素所构成的矩阵，它的用处之一即是存储2D图像数据，纹理中的每个元素都存储着对应像素的颜色。
但是这并不是它唯一的用途，比如说，在一种称为法线贴图的高级技术中，每个纹理元素都存储的是一个3D向量而非颜色的数据，
1D纹理与3D纹理就像由数据元素构成的1D，3D数组。而1D,2D以及3D纹理实则都用泛型接口ID3D12Resource来表示。
纹理不同于缓冲区资源，因为缓冲区资源仅存储数据数组，而纹理却可以具有多个mipmap层级。
支持这些特殊操作纹理的资源都被限定为一些特定的数据格式，而缓冲区资源就没有这项限制，它们可以存储任意类型的数据。
纹理所支持的数据格式由枚举DXGI_FORMAT表示。
要使纹理扮演渲染目标与着色器资源这两种角色，我们就需要为此纹理资源创建两个描述符：一个存于渲染目标堆中，一个位于着色器资源堆中。

9.2 纹理坐标
Direct3D所采用的纹理坐标系，是由指向图像水平正方向的u轴与指向图像垂直正方向的v轴所组成的。
取值范围为0<=u,v<=1的坐标(u,v)标定的是一种称为纹素的纹理元素。左上角的坐标是(0,0)，v轴的正方向指向图像的正下方。
针对3D三角形上任意一点(x,y,z)处的纹理坐标(u,v)，我们通过对顶点坐标纹理进行线性插值计算而求得。
我们能够将几个并无关联的图像合为一个大的纹理图，纹理图集。

9.3 纹理数据源
图像有多种格式，比如BMP,DDS,TGA或PNG等，对于实时图形应用程序来说，DDS图像文件格式是一种尚佳的选择：除了支持GPU可原生处理的各种图像格式，它还支持一些GPU自身就可以解压缩的压缩图像格式。

9.3.1 DDS格式概述
DDS对于3D图形来说是一种理想的格式，因为它支持一些专用于3D图形的特殊格式以及纹理类型。从本质来讲，它实为一种针对GPU而专门设计的图像格式。
DDS纹理满足用于3D图形开发的以下特征：
1,mipmap
2,GPU能自行解压的压缩格式
3,纹理数组
4,立方体图(cubemap)
5,体纹理(volume texture)
DDS格式能够支援不同的像素格式。像素格式由枚举类型DXGI_FORMAT中的成员来表示，但是并非所有的格式都适用于DDS纹理。
非压缩图像一般会采用下列格式：
1,DXGI_FORMAT_B8G8R8A8_UNORM或DXGI_FORMAT_B8G8R8X8_UNORM：适用于低动态范围图像；
2,DXGI_FORMAT_R16G16B16A16_FLOAT：适用于高动态范围图像。
Direct3D支持下列几种压缩纹理格式：BC1--BC7（详细描述见书本）

9.3.2 创建DDS文件
有两种可以将传统图像格式转换为DDS格式的方法：
1，NVIDIA公式为PS提供了一款可以将图像到处为DDS格式的插件；
2，微软公式提供了一个名为textconv的命令行工具。 
(textconv用法示例)

9.4 创建以及启用纹理
9.4.1 加载DDS文件
(DirectX::CreateDDSTextureFromFile12方法各参数含义)
(例子)

9.4.2 着色器资源视图堆
创建完纹理资源后，我们还需要为它再创建一个SRV描述符，并将其设置到一个根签名参数槽，供着色器程序使用。
(创建描述符堆)

9.4.3 创建着色器资源视图描述符
(D3D12_SHADER_RESOURCE_VIEW_DESC各字段含义)
(使用例子)

9.4.4 将纹理绑定到流水线
我们每次绘制调用时所指定的材质，都是由材质常量缓冲区来进行更新的。这就意味着在绘制调用中，所有的几何体都将使用同一组材质数据。
纹理映射技术的想法是用纹理图来取代材质常量缓冲区以获取材质数据，则将使每个像素的数据都是灵活可变化的。
(使用纹理绘制渲染项代码)

9.5 过滤器
9.5.1 放大
我们可以将纹理图中的元素看作是从连续图像中采集的离散颜色样本，但并不应认为它们是有着特定面积大小的矩形。
如果在纹理坐标(u,v)处没有与之对应的纹素点究竟会发生什么？比如：墙壁的纹理分辨率为256x256，而显示器分辨率为1024x1024。
由此就产生了纹理放大的概念，图形硬件往往会支持常数插值和线性插值两种插值方法。在实践中，线性插值使用更为普遍。
在1D情况下：假设我们有一个内含256个样本的1D纹理，并且某个插值纹理坐标为u=0.126484375，所以归一化纹理坐标就对应于0.126484375x256=32.38处的纹素。
2D线性插值又称为双线性插值，其处理流程：给出四个纹素之间的一个纹理坐标，先在水平方向u上进行两次线性插值，后在垂直方向v上再进行以此插值计算。
在以虚拟视角可以自由移动和探索交互式3D程序中，纹理放大是个无法回避的问题，在与目标保持特定距离时，纹理可能看上去还不错，但是随着观察点逐渐接近目标，其效果开始惨不忍睹。

9.5.2 缩小
纹理缩小是纹理放大的逆运算。在缩小的过程中，大量纹素将被映射到少数纹理之上。
例如，假设有一堵被256x256纹理说映射的墙壁，玩家的观察视角正紧盯着它，并逐渐后退。最终，它在屏幕上只覆盖大小为64x64像素的区域。
在这种情况下纹素的纹理坐标处往往不会有与之对应的纹理图纹素，因此还需要将常数插值过滤器与线性插值过滤器运用于纹理缩小的情况。
在初始化期间，通过对图像下采样来创建mipmap链便可制作出缩小版的纹理。
在运行时，图形硬件将根据程序员的设定，从以下两种不同的执行方案中择一而行：
1，在纹理贴图时，选择与待投影到屏幕上的几何体分辨率最为匹配的mipmap层级，并根据具体需求选用茶树插值或线性插值。这便是针对mipmap的点过滤。
2，在纹理贴图时，选取与待投影到屏幕上的结合体分辨率最为匹配的两个相邻的mipmap层级。接下来对这两种mipmap层级分别应用常量过滤和线性过滤，最后，在这两种插值纹理之间再次进行颜色的插值计算。这个过程称为mipmap的线性过滤。

9.5.3 各向异性过滤
各向异性过滤有助于缓解当多边形法向量与摄像机观察向量之间夹角过大说导致的失真现象。
这种过滤器的开销最大，但是其校正失真的效果的确对得起它所消耗的资源。

9.6 寻址模式
可将经过常数插值或线性插值的纹理定义为一个返回向量值的函数T(u,v)=(r,g,b,a)。其中0<=u,v<=1。
Direct3D允许我们采用下列4种不同方式来扩充此函数的定义域(解决输入值超出定义域这一问题)。
1，重复寻址模式：通过在坐标的每个整数点处重复绘制图像来扩充纹理函数。
2，边框颜色寻址模式：通过将每个不在范围[0,1]2内的坐标(u,v)都映射为程序员指定的颜色而扩充纹理函数。
3，钳位寻址模式：通过将范围[0,1]外的每个坐标(u,v)都映射为颜色T(u0,v0)来扩充纹理函数，其中(u0,v0)为范围[0,1]2内距离(u,v)最近的点。
4，镜像寻址模式：通过在坐标的每个整数点处绘制图像的镜像来扩充纹理函数。
在程序中总是要指定一种寻址模式的，默认为重复寻址模式。
寻址模式的枚举类型由D3D12_TEXTURE_ADDRESS_MODE表示。

9.7 采样器对象
在运行纹理的过程中，除了纹理数据本身外，还有另外两个相关的重要概念，即纹理过滤以及寻址模式。
采集纹理资源时所用的过滤器和寻址模式都是由采样器对象来定义的。一个应用程序通常需要采用若干个采样器对象以不同的方式来采集纹理。

9.7.1 创建采样器
为了将采样器绑定到着色器上供其使用，我们就需要为采样器对象绑定描述符。
如果要设置采样器描述符，还需一个采样器堆。
(例子代码)
(D3D12_SAMPLER_DESC各字段含义)

9.7.2 静态采样器
事实证明，图新应用程序通常不会使用过多的采样器。为此，Direct3D专门提供了一种特殊的方式来定义采样器数组，使用户可以在不创建采样器堆的情况下也能堆它们进行配置。
CD3DX12_ROOT_SIGNATURE_DESC类有两种参数不同的Init函数，用户可以借此为应用程序定义所用的静态采样器数组。
我们通过结构体D3D12_STATIC_SAMPLE_DESC来描述静态采样器，它与D3D12_SAMPLER_DESC有一些区别(见书本)。
(使用静态采样器的例子)

9.8 在着色器中对纹理进行采样
通过下列HLSL语法来定义纹理对象，并将其分配给特定的纹理寄存器：
Texture2D gDiffuseMap : register(t0);
纹理寄存器由tn来标定，其中，整数n表示的是纹理寄存器的槽号。
定义采样器对象，并将它们分别分配到特定的采样器寄存器。
SamplerState gsamPointWrap : register(s0);
(通过Texture2D::Sample方法采样的代码)

9.9 板条箱演示程序
9.9.1 指定纹理坐标
9.9.2 创建纹理
9.9.3 设置纹理
9.9.4 更新HLSL部分代码
(程序代码)

9.10 纹理变换
常量缓冲区变量gTexTransform与gMatTransform用于在顶点着色器中对输入的纹理坐标进行变换。
(待续)

9.11 附有纹理的山川演示程序
9.11.1 生成栅格纹理坐标
9.11.2 铺设纹理
9.11.3 纹理动画
(程序源码)







