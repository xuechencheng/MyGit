一，打包
	1，使用Lz4，压缩选项ChunkBasedCompression
	2，遍历文件夹，通过
		AssetImporter assetImporter = AssetImporter.GetAtPath(path);
		assetImporter.assetBundleName = assetbundleName;
		自动分配AssetBundle
	3，打包完成后，载入AssetBundleManifest
		遍历所有AssetBundle，为每个AssetBundle创建一个AssetBundleData，
		这个AssetBundleData包含数据 
			public string path; /// 路径
			public string version;    /// 版本
			public string allAssetNames;    /// 所有资源名
			public Hash128 hash;
		把每个AssetBundleData数据依次写入FileInfo.txt文件中
		版本号：
		从Version.txt中读取版本号，生成新的版号，把导出的文件差异化的复制到Update目录
二，热更新
	游戏资源目录：StreamingAssets
	热更新的文件夹persistentDataPath 唯一可读写的路径
	第一次开启游戏后，程序将“游戏资源目录”的内容复制到“数据目录中”
	比较版本号，大版本就去下载游戏，小版本就更新资源
	使用Md5比较文件差异
三，加载AssetBundle
四，卸载AssetBundle
大多数项目应该使用 AssetBundle.Unload(true) 并采用一种方法来确保对象不会重复。两种常用方法是：
在应用程序生命周期中具有明确定义的卸载瞬态 AssetBundle 的时间点，例如在关卡之间或在加载屏幕期间。
维护单个对象的引用计数，仅当未使用所有组成对象时才卸载 AssetBundle。这允许应用程序卸载和重新加载单个对象，而无需复制内存。

如果应用程序必须使用 AssetBundle.Unload(false)，则只能以两种方式卸载单个对象：
在场景和代码中消除对不需要的对象的所有引用。完成此操作后，调用 Resources.UnloadUnusedAssets。
以非附加方式加载场景。这样会销毁当前场景中的所有对象并自动调用 Resources.UnloadUnusedAssets。
	
开发中使用Resources文件夹，发布后使用AssetBundle
Resources.UnloadUnusedAssets();研究


2，载入资源
1，如果是本地从Application.streamingAssetsPath中解压
2，如果是服务器，