Batching

Memory Handling
内存具有两个组织结构：堆栈和堆。
栈仅限于临时存储和较小的变量，但访问速度要快得多。堆栈中的内存就会自动释放。
堆，也称为托管堆，用于较大或存储的变量更长，访问速度也更慢。当new关键字为时，从堆分配内存。
堆中的变量占用的内存必须是一个连续的块。如果声明的变量的连续内存不足，则不需要的堆内存被释放。如果可用内存仍然不足，则将扩展堆。
不再需要用于存储变量数据的堆内存称为垃圾。释放中不需要的内存中的一部分称为垃圾回收。
垃圾收集通常会发生根据需要，也可以手动触发。取决于诸如要释放内存，垃圾回收会导致性能下降。
当引入的任何滞后不被注意或影响最小时，通常使用手动触发垃圾收集来释放内存。


Object Pooling
任何使用超过了几次，并且可以销毁，应该集中起来。就像垃圾收集一样，分配内存和实例化对象很慢。不断实例化和/或在很短的时间内销毁物体，尤其是大量物体引入性能问题。
这包括子弹，枪口闪烁和程序块生成可破坏的地形。

Optimization Approaches for Project Assets

Cache
缓存所有内容需要经常访问。 声明数据而不是在Update循环中使用GetComponent该组件类型的成员，然后在“开始”或“唤醒”中调用GetComponent一次以进行分配它到数据成员。 

The proper use of Update, LateUpdate, and FixedUpdate

Coroutines




















