优化图形性能
游戏的图形部分主要影响计算机的哪两个系统？
CPU 和 GPU
什么是一切优化的首要法则？因为GPU与CPU的优化策略大不相同（甚至相反；例如，通常在优化 CPU 时让 GPU 做更多工作，反之亦然）。
找到性能问题所在
常见的瓶颈：GPU通常受什么制约？
填充率或内存带宽
进行什么操作之后游戏运行更快，表明GPU填充率可能是限制因素？
降低显示分辨率
CPU 通常受到需要什么限制？
渲染的批次数
检查 Rendering Statistics窗口中的什么？渲染的批次越多，CPU 成本越高。
batches
不太常见的瓶颈：GPU有太多顶点需要处理。可接受的能确保良好性能的顶点数量取决于GPU和顶点着色器的复杂程度。一般来说，移动端应不超过多少个顶点。另一方面，即使有数百万个顶点，PC 也能管理到位，不过最好还是通过优化尽可能减少此数量。
十万个
如果渲染在GPU或CPU方面不是问题，则可能在其他地方存在问题，例如在脚本或物理系统中。请使用什么找出问题？
Unity Profiler
如果有一千个三角形，如果它们都在一个网格中，而不是每个三角形在一个网格中（这种情况下加起来就有 1000 个网格），则 CPU 处理起来就比较容易。两种方案的什么成本非常相似？但CPU完成渲染一千个对象（而不是一个）的工作要高得多。
GPU
减少可见对象数量。要减少CPU需要执行的工作量，请执行哪些操作？
通过手动方式或使用Unity的绘制调用批处理将近处对象组合在一起。
通过将单独的纹理放入更大的纹理图集，在对象中使用更少的材质。
减少可能导致对象多次渲染的因素（例如反射、阴影和每像素光照）。
将对象组合在一起，使每个网格至少有几百个三角形，并使整个网格只使用一种材质。请注意，组合两个不共享材质的对象会提高性能吗？
不会
GPU优化模型几何体有两个基本规则是什么？
除非必要，否则不要使用三角形
尽可能降低 UV 贴图接缝和硬边（双倍顶点）的数量
图形硬件必须处理的实际顶点数通常与3D应用程序报告的数量相同吗？
不同
建模应用程序显示的是构成模型的不同角点的数量（称为几何顶点数）。但是，对于显卡，为了进行渲染，需要将一些几何顶点拆分成两个甚至更多个逻辑顶点。如果顶点具有多个法线、UV 坐标或顶点颜色，则必须将其拆分。因此，Unity 中的顶点计数通常什么样3D 应用程序给出的计数。
高于 
虽然模型中的几何体数量主要与 GPU 相关，但 Unity 中的某些功能也要在什么上处理模型（例如，网格蒙皮）？
CPU
速度最快的方案是始终创建根本不需要计算的光照。要做到这一点，使用什么只需一次“烘焙”静态光照，而无需每帧计算？
光照贴图
对于所有像素，什么光照会为每个受影响的像素增加渲染工作，可能导致对象在多个 pass 中被渲染？
动态光照
尽量避免什么照射单个对象的情况？
多个光源
避免组合距离足够远而需要受到不同像素光照影响的网格。通常情况下，为渲染组合对象而必须创建的 pass 数为多少？因此进行网格组合并不会获得任何好处。
每个单独对象的 pass 数之和
使用什么设置可修改多少个光源用于像素光照以及多少个用于顶点光照？
质量设置 (Quality Settings) 
每个光源都有Render Mode设置，可设置为Important或 Not Important；标记为什么的光源具有较低的渲染开销？
Not Important
假设有一个驾驶游戏，玩家的汽车在黑暗中行驶，前照灯已打开。前照灯可能是游戏中视觉上最重要的光源，因此它们的 Render Mode 应设置为 Important。游戏中可能还有其他不太重要的光源，比如其他汽车的尾灯或远处的灯柱，这些光源不能通过像素光照来大幅改善视觉效果。这种情况下，可放心地将这些光源的 Render Mode 设置为什么，从而避免将渲染能力浪费在无用之处。
Not Important
通过优化什么光照可以节省 CPU 和 GPU 工作量：CPU 的绘制调用将减少，而 GPU 要处理的顶点将减少，同时为所有其他对象渲染栅格化的像素也将减少？
每像素光照
使用什么可减小纹理的大小。这种做法可加快加载时间、减小内存占用并显著提高渲染性能？
压缩纹理
与什么纹理所需的内存带宽相比，压缩纹理使用的内存带宽要小得多？
未压缩的32位RGBA纹理
对于3D场景中使用的纹理，应始终启用什么选项？Mipmap纹理使GPU能够为较小的三角形使用较低分辨率的纹理。这一点类似于纹理压缩可以帮助限制GPU渲染时传输的纹理数据量。
Generate mipmaps
此规则的唯一例外是当已知纹理像素将什么比例映射到渲染的屏幕像素时（与 UI 元素或在 2D 游戏中一样）？
1:1
LOD（细节级别）和每层剔除距离有哪些方式实现此目标？
使用细节级别系统
手动设置摄像机上的每层剔除距离
将小对象放入单独一层，并使用 Camera.layerCullDistances 脚本函数设置每层剔除距离
什么阴影很不错，但它们对性能有很大影响，同时会增加 CPU 的绘制调用次数和 GPU 的处理量？
实时阴影
建议怎么样优化着色器以减少计算和纹理读取，从而在低端 GPU 机器上获得良好的性能？
手动优化
移动端和低端 PC 显卡的有哪些指导原则？
复杂的数学运算和浮点精度
超越数学函数（例如 pow、exp、log、cos、 sin、tan）都很消耗资源，所以尽量避免使用它们。如果可能，请尽量考虑使用什么作为复杂数学计算的替代方法？
查找纹理
避免什么样编写运算（如 normalize、dot、inversesqrt）？Unity 的内置选项确保驱动程序可以生成好得多的代码。请记住，Alpha 测试 (discard) 运算通常会使片元着色器变慢。
编写自己的运算
虽然什么变量的精度（float 与 half 与 fixed） 在桌面平台 GPU 上很大程度上会被忽略，但在移动端 GPU 上 对于获得良好性能非常重要。
浮点变量
用于提高游戏运行速度的简单核对表
在针对 PC 平台进行构建时，保持顶点数量低于 200K 和 3M/帧（具体值取决于目标 GPU）。
如果要使用内置着色器，请从 Mobile 或 Unlit 类别中选取。这些类别也适用于非移动平台，但它们是更复杂着色器的简化和近似版本。
保持每个场景使用较少的不同材质，并尽可能在不同对象之间共享材质。
在非移动对象上设置 Static 属性以便允许内部优化，如静态批处理。
只有一个（最好是方向性的）pixel light 影响几何体（而不是有多个）。
烘焙光照而不是使用动态光照。
尽可能使用压缩纹理格式，并使用 16 位纹理而非 32 位纹理。
尽可能避免使用雾效。
如果复杂的静态场景具有大量遮挡，使用遮挡剔除减少可见几何体数量和绘制调用次数。设计关卡时注意遮挡剔除。
使用天空盒“伪造”远处的几何体。
使用像素着色器或纹理组合器来混合多个纹理而不是使用多 pass 方法。
尽可能使用 half 精度变量。
最大限度减少在像素着色器中使用复杂的数学运算，例如 pow、sin 和 cos。
每个片元使用更少的纹理。
参考文档：光照性能

绘制调用批处理
要在屏幕上绘制游戏对象，引擎必须向图形API（例如 OpenGL 或 Direct3D）发出什么命令？
绘制调用
什么通常为资源密集型操作，图形API为每次绘制调用执行大量工作，从而导致CPU端的性能开销？
绘制调用
此开销的主要原因是什么，而这种情况会导致图形驱动程序中执行资源密集型验证和转换步骤？
绘制调用之间的状态变化（例如切换到不同材质）
Unity 使用两种方法来应对此情况：
动态批处理：对于足够小的网格，此方法会在CPU上转换网格的顶点，将许多相似顶点组合在一起，并一次性绘制它们。
静态批处理：将静态（不移动）游戏对象组合成大网格，并以较快的速度渲染它们。
静态批处理会导致内存和存储开销，动态批处理会产生一些什么开销？
CPU
只有共享相同材质的游戏对象才可一起接受批处理。因此，如果想要实现良好批处理，应在尽可能多的不同游戏对象之间怎么样处理？
共享材质
如果两种相同材质仅在纹理上不同，可将这些纹理组合成单个大纹理。此过程通常称为什么？一旦纹理位于相同图集中，即可使用单个材质。
纹理镶嵌
如果需要从脚本访问共享材质属性，必须注意，修改Renderer.material将创建该材质的副本。应改用什么来保留共享的材质？
Renderer.sharedMaterial
阴影投射物即使材质不同，通常也可以在渲染时接受批处理。Unity 中的阴影投射物即使具有不同材质也可以使用动态批处理，只要阴影满足什么条件相同即可。
 pass 所需材质中的值
Dynamic batching（Meshes），移动的游戏对象网格需要满足哪些条件？
Batching dynamic GameObjects has certain overhead per vertex, so batching is applied only to Meshes containing no more than 900 vertex attributes, and no more than 300 vertices.
如果游戏对象在变换中包含镜像，则不会对这些对象进行批处理（例如，具有 +1 缩放的游戏对象 A 和具有 –1 缩放的游戏对象 B 无法一起接受批处理）。
即使游戏对象基本相同，使用不同的材质实例也会导致游戏对象不能一起接受批处理。例外情况是阴影投射物渲染。
带有光照贴图的游戏对象具有其他渲染器参数：光照贴图索引和光照贴图偏移/缩放。通常，动态光照贴图的游戏对象应指向要批处理的完全相同的光照贴图位置。
多 pass 着色器会中断批处理。
Dynamic batching (Particle Systems, Line Renderers, Trail Renderers)
For components with geometry that Unity generates dynamically, dynamic batching works differently compared to how it works for Meshes.
For each compatible renderer type, Unity builds all batchable content into 1 large Vertex Buffer.
The renderer sets up the Material state for the batch.
Unity binds the Vertex Buffer to the Graphics Device.
For each Renderer in the batch, Unity updates the offset into the Vertex Buffer, and then submits a new draw call.
静态批处理的前提是什么？这种处理方式通常比动态批处理更高效（它不会在 CPU 上转换顶点），但是使用更多内存。例如，在茂密森林关卡中，将树标记为静态可能会产生严重的内存影响。
共享相同材质并且不移动

角色建模的性能优化
有哪些能够优化渲染速度的角色建模技巧？
使用单个带蒙皮的网格渲染器，使用尽可能少的材质，使用尽可能少的骨骼，多边形数量，正向和反向动力学保持分离
只有在需要为角色的不同的部分使用不同着色器（例如，眼睛的特殊着色器）时，您才应该考虑使用多种材质。其余大多数情况下，每个角色有多少材质就应该足够了？
两到三种材质
典型的桌面游戏中的骨骼层级视图大概拥有多大范围？骨骼的数量越少，性能就越好。在使用大约 30 根骨骼的情况下，桌面平台上可以获得极佳质量，移动平台上也能获得比较好的质量。理想情况下，移动设备游戏的骨骼数量应保持在 30 根以下，桌面游戏的骨骼数量也不要超出 30 根太多。
15 到 60 根骨骼
您应该使用的多边形数量取决于您需要达到的质量，以及您的目标平台。对于移动设备而言，每个网格多少个多边形就可以取得良好的效果？而对于桌面平台，理想的数量范围大约为 1500 到 4000。如果游戏经常会同屏内出现大量角色，那么您可能需要减少每个网格的多边形数量。
300 到 1500 个多边形
在导入动画时，模型的反向动力学 (IK) 节点将被烘焙为正向动力学 (FK)，因此 Unity 根本不需要什么？
IK 节点

渲染 Statistics 窗口
参考文档：每个参数的含义

帧调试器
要远程使用帧调试器，播放器必须支持多线程渲染（例如，WebGL，iOS 不支持这种渲染方式，因此无法运行帧调试器），大多数 Unity 平台都支持多线程渲染，其次在构建时必须选中什么？
Development Build

优化着色器加载时间（待续）


 



















