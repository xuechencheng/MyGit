移动平台开发者检查清单
崩溃
如果想了解目前发生的情况，请查看什么？您将在该日志中看到所有内容，而非只有控制台部分。可尝试了解目前发生的情况，并查看编码会话的完整日志。这将有助于找出导致 Unity 崩溃的原因或弄清楚资源的问题。
editor.log

性能分析
并非所有用户代码都显示在性能分析器中。但可使用什么使所需的用户代码显示在性能分析器中？
Profiler.BeginSample 和 Profiler.EndSample
使用什么可获取使用的 Mono 内存总量？
System.GC.GetTotalMemory
使用什么可获取使用的 Unity 内存总量？
Profiler.usedHeapSize

优化
在移动平台，本质上将受填充率限制（填充率 = 屏幕像素 * 着色器复杂度 * 过度绘制），而什么是导致问题的最常见原因？
过于复杂的着色器
因此，请使用 Unity 附带的移动端着色器，或设计您自己的着色器，但尽可能简化它们。如果可能，通过将代码移动到什么来简化像素着色器？
顶点着色器
如果降低质量设置 (Quality Settings) 中的纹理质量 (Texture Quality) 能提高游戏运行速度，表明可能受到什么的限制？因此，应压缩纹理、使用 Mipmap、减小纹理大小等。
内存带宽
使用什么技术将对象简化或在对象移动到更远位置时完全剔除它们？
LOD（细节级别）
以下是确保良好实践的检查清单：
1.保持材质数量尽可能少。这样使 Unity 更容易进行批量处理。 
1.使用纹理图集（包含子图像集合的大图像）代替多个单独的纹理。这些纹理图集的加载速度更快，状态切换更少，并支持批处理。
1.如果使用纹理图集和共享材质，请用 Renderer.sharedMaterial 而不是 Renderer.material。 
1.前向渲染的像素光源的成本很高。 * 尽可能使用光照贴图而不是实时光源。 * 调整质量设置中的像素光源数。本质上只有方向光应该是每个像素光源，其他所有光源都应该是每顶点光源。当然这取决于游戏。 
1.尝试质量设置中的光源渲染模式，以获取正确的优先级。 
1.除非确实有必要，否则避免使用镂空（Alpha 测试）着色器。 
1.保持透明（Alpha 混合）屏幕覆盖率最小化。 
1.尽量避免多个光源为给定对象提供光照的情况。 
1.尝试减少着色器通道（阴影、像素光源、反射）的总数。 
1.渲染顺序至关重要。一般情况为： * 完全不透明对象（大致为从前到后）。 * Alpha 测试对象（大致为从前到后）。 * 天空盒。 * Alpha 混合对象（必要时从后到前）。 
1.后期处理在移动端的成本很高，请小心使用。 
1.粒子：减少过度绘制，使用尽可能最简单的着色器。 
1.使每帧都修改的网格的缓冲区加倍：
如果降低显示分辨率，游戏运行速度是否会加快，如果是，表明受限于什么？
填充率
尝试通过以下方法降低着色器复杂性：
避免使用 Alpha 测试着色器；改用 Alpha 混合版本。
使用简单、优化的着色器代码（例如 Unity 附带的“Mobile”着色器）。
避免在着色器代码中使用成本太高的数学函数（pow、exp、log、cos、sin、tan 等）。请考虑改用预先计算的查找纹理。
选择尽可能低的数字精度格式（float、half、fixedin Cg）以获得最佳性能。
如果未受到什么的约束，那么批处理实际上对性能更不利，因为这种处理方式会降低剔除效率并使更多对象受到光源的影响！
绘制调用的约束
物理组件可能很消耗 CPU。可通过 Editor 性能分析器对其进行分析。如果物理组件在 CPU 上占用太多时间：
尽可能将 Time.fixedDeltaTime_（在 Project settings > Time 中）调整到允许的最大值。如果游戏的移动速度很慢，所需的固定更新可能少于具有快动作的游戏。快节奏的游戏需要更频繁的计算，因此 fixedDeltaTime_ 将需要更低的值，否则碰撞可能失败。
Physics.solverIterationCount (Physics Manager)。
使用尽可能少的布料 (Cloth) 对象。
仅在必要时才使用刚体。
优先使用原始碰撞体而不是网格碰撞体。
绝不要移动静态碰撞体（即没有刚体的碰撞体），因为这会导致很大的性能影响。这种碰撞体在性能分析器中显示为“Static Collider.Move”，但实际处理在 Physics.Simulate 中进行。如有必要，添加刚体，并将 isKinematic 设置为 true。
在 Windows 上，如果需要，可使用 NVidia 的 AgPerfMon 性能分析工具集来获取更多详细信息。
资源包
资源包在一定限制程度上缓存于设备上
使用 Editor API 进行创建
使用 WWW API 进行加载：WWW.LoadFromCacheOrDownload，或作为资源加载：AssetBundle.CreateFromMemory 或 AssetBundle.CreateFromFile
使用 AssetBundle.Unload 进行卸载。可选择卸载资源包但保留已加载的资源。即使已加载的资源在场景中被引用，也可以终止所有这些资源
Resources.UnloadUnusedAssets 卸载场景中不再引用的所有资源。所以，切记终止对不再需要的资源的引用。系统绝不会对公共变量和静态变量进行垃圾回收。
Resources.UnloadAsset 从内存中卸载特定资源。如果需要，可从磁盘重新加载该资源。
不同情况有不同解决方案，但一定要压缩什么，除非您确定不应该压缩？
纹理
ETC/RGBA16 - Android 的默认设置，但可根据 GPU 供应商做调整。最好的方法是尽可能使用什么？Alpha 纹理可使用两个 ETC 文件，并将一个通道用于 Alpha
ETC
iOS 的默认设置，适用于大多数情况
PVRTC
启用了Get/Set像素的纹理 - 占用空间怎么样，除非需要 Get/Set，否则应取消选中？
加倍





























































