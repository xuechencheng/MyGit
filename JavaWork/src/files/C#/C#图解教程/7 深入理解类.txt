7 深入理解类
7.1 类成员
7.2 成员修饰符的顺序
7.3 实例类成员
7.4 静态字段
7.5 从类的外部访问静态成员
访问静态成员的另一种方法根本不需要使用前缀，只需要在该成员所属的类中包含一个using static声明。
7.6 静态函数成员
7.7 其他静态类成员类型
7.8 成员常量
const int IntVal = 100
7.9 常量与静态量
常量成员表现得像静态值，但不能将常量声明为static。
7.10 属性
属性的每个单词的首字母都是大写
自动实现属性：public int MyValue{set;get;}

7.11 实例构造函数
7.12 静态构造函数
类只能有一个静态构造函数，而且不能带参数。静态构造函数不能有访问修饰符。
static Class1(){}
不能从程序中显式调用静态构造函数，系统会自动调用它们：
1，在类的任何实例被创建之前
2，在类的任何静态成员被引用之前

7.13 对象初始化语句
对象初始化语句扩展了创建语法，在表达式的尾部放置一组成员初始化语句。
new TypeName{FieldOrProp = InitExpr,FieldOrProp = InitExpr,……}
初始化发生在构造方法执行之后。

7.14 析构函数
析构函数执行在类的实例被销毁之前需要的清理或释放非托管资源的行为。非托管资源是指通过win32API获得的文件句柄，或非托管内存块。
使用.NET资源是无法得到它们的，因此如果坚持使用.NET类，就不需要为类编写析构函数。

7.15 readonly修饰符
字段可以使用readonly修饰符声明。其作用类似于将字段声明为const，一旦值被设定就不能改变。
const字段的值必须可在编译时决定，而readonly字段的值可以在运行时决定。
const的行为总是静态的，而readonly可以是实例字段，也可以是静态字段。

7.16 this关键字
this用于下列目的：用于区分类的成员和局部变量或参数；作为调用方法的实参。

7.17 索引器
ReturnType this[Type param1,...]{set{} get{}}

7.18 访问器的访问修饰符
默认情况下，成员的两个访问器的访问级别和成员自身相同。
不过，你可以为两个访问器分配不同的访问级别。
public string Name{get;private set}
















