8 类和继承
8.1 类继承
8.2 访问继承的成员
8.3 所有类都派生自object类
一个类声明的基类规格说明中只能有一个单独的类，这成为单继承。
8.4 屏蔽基类的成员
要让编译器知道你在故意屏蔽继承的成员，可使用new修饰符。
8.5 基类访问
基类访问表达式：由关键字base后面跟一个点和成员的名称组成。
8.6 基类的引用
使用new不能实现多态。
虚方法可以使基类的引用访问升至派生类内。
可以使用基类引用派生类的方法：要满足以下条件：派生类的方法和基类的方法有相同的签名和返回类型；基类的方法使用virtual标注；派生类的方法使用override标注。
virtual/override，除了方法，在属性，事件以及索引器上的用法也一样。
8.7 构造函数的执行
构造函数初始化语句：public MyDerivedClass(int x, string s):base( s, x)
使用当前类中其他的构造函数。 public MyClass(int x):this(x,"Using Default String")
类的可访问性有两个级别：public和internal。
标记为internal的类只能被自己所在的程序集内的类看到。这是默认的可访问级别。

8.8 程序集间的继承
8.9 成员访问修饰符
5个成员访问级别的名称：public,private,protected,internal和proteced internal。
成员的访问性不能比它的类高。
private能被嵌套在它的类中的类成员访问。
protected访问级别如同private访问级别，但它允许派生自该类的类访问该成员。
比较为internal的成员对程序集内部的所有类可见，但对程序集外部的类不可见。
protected和internal的关系是并集而不是交集。

8.10 抽象成员
抽象成员是指设计为被覆写的函数成员。包括以下特征：
1，必须是一个函数成员，字段和常量不能成为抽象成员；
2，必须用abstract修饰符标记；
3，不能有实现代码块。
有四种类型的抽象成员：方法，属性，事件和索引器。
虚成员和抽象成员：virtual和abstract。

8.11 抽象类
不能创建抽象类的实例。abstract class MyClass{}

8.12 密封类
密封类只能被用作独立的类，它不能被用作基类。
密封类使用sealed修饰符标注。

8.13 静态类
静态类中所有成员都是静态的。
静态类可以有一个静态构造函数。
静态类似隐式封闭的，不能继承静态类。

8.14 扩展方法
static class ExtendMyData{public static double Average(this MyData md){}}


















