3 资源管理
所谓资源就是，一旦用了它，将来必须还给系统。
条款13 以对象管理资源
以对象管理资源的两个关键想法：
1，获得资源后立刻放进管理对象内；
2，管理对象运用析构函数确保资源被释放。
auto_ptr有一个特殊的性质：通过copy构造函数或copy assignment操作符复制它们，它们会变成null，而复制所得的指针将取得资源的唯一拥有权。
受autp_ptrs管理的资源必须绝对没有一个以上的auto_ptr同时指向它。这意味着auto_ptrs并非管理动态分配资源的神兵利器。
auto_ptr的替代方案是“引用计数型智慧指针”（RCSP）。
RCSP提供的行为类似垃圾回收，不同的是RCSP无法打破环状引用（例如，两个其实已经没被使用的对象彼此互指）。
trl::shared_ptr就是个RCSP。
auto_ptr和shared_ptr两者都在其析构函数内做delete而不是delete[]动作。这意味着在动态分配而得的array身上使用auto_ptr和shared_ptr是馊主意。
并没有特别针对C++动态分配数组设计类似的智能指针，因为vector和string几乎总是可以取代动态分配而得的数组。

条款14：在资源管理类中小心copying行为
然而并非所有资源都是heap-based，对那种资源而言，像auto_ptr和shared_ptr这样的只能指针往往不适合作为资源掌握者。既然如此，有可能偶尔你会发现，你需要建立自己的资源管理类。
RAII守则：资源在构造期间获得，在析构期间释放。
每一位RAII class作者一定需要面对的：“当一个RAII对象被复制，会发生什么事？”大多数时候你会选择以下两种可能：禁止复制；对底层资源祭出“引用计数法”；复制底部资源；转移底部资源的拥有权。
普遍而常见的RAII class copying行为是：抑制copying，施行引用计数法。不过其他行为也都可能被实现。

条款15：在资源管理类中提供对原始资源的访问
shared_ptr和auto_ptr都是提供一个get成员函数，用来执行显式转换，也就是返回智能指针内的原始指针的复件。
APIs旺旺要求访问原始资源，所以每一个RAII class应该提供一个“取得其所管理子资源”的办法。
对原始资源的访问可能经由显示转换或隐式转换。一般而言显示转换比较安全，但隐式转换对客户比较方便。

条款16：成对使用new和delete时要采取相同形式
当你调用new时使用[]，你必须在对应调用delete时也是用[]。
如果你在表达式中不使用[]，一定不要在相应的delete表达式中使用[]。
delete [] array;

条款17：以独立语句将newed对象置入智能指针
以独立语句将newed对象置入智能指针内。如果不这样做，一旦异常抛出，有可能导致难以觉察的资源泄露。


