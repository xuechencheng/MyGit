23 垃圾收集
弱引用表，析构器和函数collectgarbage是在Lua语言中用来辅助垃圾收集器的主要机制。
弱引用表允许收集Lua语言中还可以被程序访问的对象。
析构器允许收集不在垃圾收集器直接控制下的外部对象。
函数collectgarbage则允许我们控制垃圾收集器的步长。

23.1 弱引用表
所谓的弱引用是一种不在垃圾收集器考虑范围内的对象引用。
如果一个对象的所有引用都是弱引用，那么垃圾收集器将会回收这个对象并删除这些弱引用。
Lua用语言通过弱引用表实现弱引用，弱引用表就是元素均为弱引用的表。
这意味着如果一个对象只被一个弱引用表持有，那么Lua语言最终会回收这个对象。
在一个弱引用表中，键和值都可以是弱引用的。这就意味着有三种类型的弱引用表。
无论是哪种类型的弱引用表，只要有一个键或值被回收了，那么对应的整个键值对都会被从表中删除。
一个表是否为弱引用表是由其元表中的__mode字段所决定的。
当这个字段存在时，其值对应为一个字符串：如果这个字符串是“k”，那么这个表的键是弱引用，“v”和“kv”同理。
调用collectgarbage强制垃圾收集器进行一次完整的垃圾收集。
只有对象可以从弱引用表中被移除，而像数字，字符串和布尔这样的值是不可回收的。

23.2 记忆函数
通过记忆函数的执行结果，在后续使用相同参数再次调用该函数时直接返回之前记忆的结果。
通过缓存可以实现，通过虚表又可以保证能存不会一直不释放。

23.3 对象属性

23.4 回顾具有默认值的表

23.5 瞬表
一种棘手的情况是，一个具有弱引用键的表中的值又引用了对应的键。
Lua语言通过瞬表的概念来解决上述问题。一个具有弱引用键和强引用值的表称为瞬表。
即使v指向了k，垃圾收集器最终会收集k并把元素从表中移除。

23.6 析构器
Lua语言通过元方法__gc实现析构器。

23.7 垃圾收集器
一直到5.0，Lua语言使用的都是一个简单的标记-清除式垃圾收集器。
Lua语言会时不时地停止主程序的运行来执行一次完整的垃圾收集周期。
垃圾收集周期由四个阶段组成：标记，清理，清除和析构。
Lua5.1使用了增量式垃圾收集器。不需要在垃圾收集期间停止主程序的运行。
Lua5.2引入了紧急垃圾收集。

23.8 控制垃圾收集的步长
通过函数collectgarbage可以对垃圾收集器进行一些额外的控制。
该函数实际是几个函数的集合体。

