第一章 向量代数
1.1 向量
向量是一种兼具大小和方向的量。
向量的绘制位置之于其自身是无足轻重的。
两个向量相等，当且仅当它们的长度相等且方向相同。

1.1.1 向量与坐标系
同一个向量在不同的坐标系中有着不同的坐标表示。
每当我们根据坐标来确定一个向量时，其对应的坐标总是相对于某一参考系而言的。
我们需要记录向量在每一种坐标系中的对应坐标，也需要知道如何将向量坐标在不同的标架之间进行转换。
向量和点都能够用坐标(x,y,z)来表示，但他们的意义却是截然不同的。

1.1.2 左手坐标系和右手坐标系
Direct3D采用的是左手坐标系。
伸出左手，并拢手指，假设它们指向的是x轴的正方向，再弯曲四指指向y轴正方向，则最后伸直拇指的方向大约就是z轴的正方向。

1.1.3 向量的基本运算
向量加法的几何意义：把向量u进行平移，使u的尾部与v的头部重合。此时，u和v的和即为以v的尾部为起点，以平移后的u的头部为终点做所的向量。
向量的加法运算与物理学中不同作用力合成合力的规则是一致的。
v-u的差值仍是一个向量，该向量自u的头部始至v的头部终。
如果我们将u和v看做两个点，那么v-u得到的是一个从点u指向v的向量，这种解释方式使我们找出向量的方向。

1.2 长度和单位向量
向量大小的几何意义是对应有向线段的长度，用双竖线表示。
把一个向量的长度变为单位长度称为向量的规范化处理。具体实现方法是，将向量的每个分量分别除以该向量的模。

1.3 点积
点积就是向量间对应分量的乘积之和。
两向量的点积为：两向量夹角的余弦值乘以这两个向量的模。
特别的，如果向量u和向量v都是单位向量，那么u.v就等于两向量夹角的余弦值。
如果u.v=0，那么u和v垂直。如果u.v>0，那么两向量的夹角小于90，如果u.v<0，那么两向量的夹角大于90。
v.n的几何意义，我们称p为向量v落在向量n上的正交投影。
如果n是单位向量，那么向量v落在向量n上的正交投影为(v.n)n。如果n不是单位向量就除以n的模的平方。

正交化
如果向量集{v0,...,vn-1}中的每个向量都是互相正交且皆为单位长度，那么我们就称此集合是规范正交的。
3D情况下，假设有向量集{v0,v1,v2}，首先使w0=v0,通过令v1减去它在w0方向上的分量，让它正交于w0。
接下来，通过令v2依次减去它在w0和w1方向上的分量（投影），使之同时正交于w0,w1。
将给定集合内的向量vi添加到规范正交集中时，我们需要令vi减去它在现有规范正交集中其他向量方向上的分量（投影）。

点积的应用：夹角，投影和正交化

1.4 叉积
叉积的计算结果也为向量。
只有3D向量的叉积有定义，不存在2D向量叉积。
假设3D向量u和v的叉积得到的是另一个向量w，则w与向量u,v彼此正交。
叉积的计算公式。
叉积的方向根据不同坐标系使用左手定则和右手定则。
u x v = - v x u
左手定则：伸出左手，使并拢的左手手指指向向量u的方向，再以小于π的角度弯曲四指，使之指向向量v的方向，那么最后伸直的大拇指约略指向的即为w=uxv的方向。

1.4.1 2D向量的伪叉积

1.4.2 通过叉积来进行正交化处理
w0 = v0 / |v0|
w2 = w0 x v1 / |w0 x v1|
w1 = w2 x w0

1.5 点

1.6 利用DirectXMath库进行向量运算
利用一条SIMD指令即可同时对4个32位浮点数或整数进行运算。
为了使用DirectXMath库，我们需要向代码中添加头文件#include <DirectXMath.h>，而为了一些相关的数据类型还要加入头文件#include <DirectXPackedVector.h>。
针对x86平台，我们需要启动SSE2指令集。对于所有平台，我们还应当启动快速浮点模型fp:fast。

1.6.1 向量类型
在DirectXMath库中，核心向量类型是XMVECTOR，它被映射到SIMD硬件寄存器。
通过SIMD指令的配合，利用这种具有128位的类型能一次性处理4个32位的浮点数。
在开启SSE2后，此类型在x86和x64平台的定义是：typedef __m128 XMVECTOR。
这里的__m128是一种特殊的SIMD类型，在计算向量的过程中，必须通过此类型才可充分利用SIMD技术。
我们通过SIMD技术来处理2D和3D向量运算，而计算过程中用不到的向量分量则被它置零并忽略。
XMVECTOR类中的数据成员，建议分别使用XMFLOAT2，XMFLOAT3和XMFLOAT4类型加以代替。
如果直接使用上述这些类型用于计算，却依然不能充分发挥SIMD技术的高效特性。为此，我们还需要将这些类型的实例转换为XMVECTOR类型。转换过程可以通过DirectXMath库的加载函数实现。
相反地，DirectXMath库也提供了用来将XMVECTOR类型转换为XMFLOATn类型的存储函数。
总结一下：
1，局部变量或全局变量用XMVECTOR类型。
2，对于类中的数据成员，使用XMFLOAT2，XMFLOAT3和XMFLOAT4类型。
3，在运算之前，通过加载函数将XMFLOATn类型转换为XMVECTOR类型。
4，用XMVECTOR实例进行运算。
5，通过存储函数将XMVECTOR类型转换为XMFLOATn类型。

1.6.2 加载方法和存储方法
参考文档：将XMFLOATn类型加载到XMVECTOR类型
XMVECTOR XM_CALLCONV XMLoadFloat3(const XMFLOAT3 *pSource)
参考文档：将数据从XMVECTOR类型存储到XMFLOATn类型
void XM_CALLCONV XMStoreFloat3(XMFLOAT3 *pDestination, FXMVECTOR V)
当我们只希望从XMVECTOR实例中得到某一个向量分量或将某一个向量分量转换为XMVECTOR类型时，相关的存取方法如下：
float XM_CALLCONV XMVectorGetX(FXMVECTOR v);
XMVECTOR XM_CALLCONV XMVectorSetX(FXMVECTOR V,float x)

1.6.3 参数的传递
为了提高效率，可以将XMVECTOR类型的值作为函数的参数，直接传送至SSE/SSE2寄存器里，而不存在于栈内。
为了不受平台和编译器影响，我们将利用FXMVECTOR，GXMVECTOR，HXMVECTOR和CXMVECTOR类型来传递XMVECTOR类型的参数。
此外，一定要把调用约定注解XM_CALLCONV加载函数名之前，它会根据编译器的版本确定对应的调用约定属性。
传递XMVECTOR参数的规则如下：
1，前3个XMVECTOR参数应当用类型FXMVECTOR；
2，前4个XMVECTOR参数应当用类型GXMVECTOR；
3，第5，6个XMVECTOR参数应当用类型CXMVECTOR；
4，其余的XMVECTOR参数应当用类型CXMVECTOR。
实例：传递XMVECTOR类型参数的方法
在XMVECTOR类型的参数之间，我们也可以掺杂其他非XMVECTOR类型参数。统计XMVECTOR参数的数量时，会对其他类型的参数视若无睹。
传递XMVECTOR参数的规则仅适用于输入参数。输出的XMVECTOR参数不会占用SSE/SSE2寄存器，所以它们的处理方式与非XMVECTOR类型的参数一致。

1.6.4 常向量
XMVECTOR类型的常量实例应当用XMVECTORF32类型表示。
static const XMVECTORF32 g_vHalfVector = { 0.5f, 0.5f, 0.5f, 0.5f}
XMVECTORF32是一种按16字节对齐的结构体，数学库中还提供了将它转换至XMVECTOR类型的运算符。其定义如下：参考文档
也可以通过XMVECTORU32类型来创建由整型数据结构构成的XMVECTOR常向量。

1.6.5 重载运算符
XMVECTOR类型针对向量的加法运算，减法运算和标量乘法，都分别提供了对应的重载运算符。
参考文档：见书本

1.6.6 杂项
DirectXMath库定义了一组与π有关的常用数学常量近似值。
另外，它用下列内联函数实现弧度和角度的互相转化。
DirectXMath库还定义了求出两个数间较大值及较小值的函数。

1.6.7 Setter函数
DirectXMath库提供了下列函数，以设置XMVECTOR类型中的数据。

1.6.8 向量函数
DirectXMath库提供了下面的函数来执行各种向量运算。我们主要围绕3D向量的运算函数进行讲解，类似的运算还有2D和4D版本。除了表示维度的数字不同以外，这几种版本的函数名都相同。

1.6.9 浮点数误差






























