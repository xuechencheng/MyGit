第8章 编译，执行与错误
区别解释型语言的主要特征并不在于是否能够编译它们，而是在于编译器是否是语言运行时库的一部分，即是否有能力（并且轻易地）执行动态生成的代码。

8.1 编译
dofile是一个辅助函数，loadfile才做了真正核心的工作。
类似于dofile，loadfile会从一个文件加载Lua代码块，但它不会运行代码，只是编译代码，然后将编译结果作为一个函数返回。
一般dofile可以这样来定义：
function dofile(filename)
	local f = assert(loadfile(filename))
	return f()
end
如果需要多次运行一个文件，那么只需要再调用一次loadfile后，多次调用它的返回结果就可以了。相对于多次调用dofile来说，由于只编译一次文件，开销就小得多了。
loadstring与loadfile类似，不同之处在于它是从一个字符串中读取代码，而非从文件读取。
f = loadstring("i = i + 1")f就变成了一个函数，每次调用时就执行i = i + 1
f = loadstring("i = i + 1")基本上等价于f = function() i = i + 1 end;但第二段代码快得多。
因为第二段代码只在编译时编译一次，而第一段代码却在每次调用loadstring时都被重新编译。
由于loadstring在编译时不涉及词法域，所以上述两端代码并不等价。loadstring总是在全局环境中编译它的字符串。
loadstring最典型的用处是执行外部代码，也就是那些位于程序之外的代码。例如，若让用户来参与一个函数的定义，那么这是就需要让用户输入函数代码，然后调用loadstring来对其求值。
例子：local func = assert(loadstring("return " .. l))   func()
loadfile和loadstring分别从文件和字符串中读取程序块，读取器函数可以分几次返回一个程序块，load会反复调用它，直到返回nil为止。

8.2 C代码
与Lua代码不同的是，C代码需要在使用前先链接入一个应用程序。
在大多数主流系统中，达成这种链接最简单的方法是动态链接机制。
Lua通常不会包含任何无法通过ANSI C来实现的机制。不过动态链接却有些不同。不过，动态链接却有些不同。
Lua提供的所有关于动态链接的功能都聚集在一个函数中，即package.loadlib。该函数有两个字符串参数。
local path = '/usr/local/lib/lua/5.1/socket.so'
local f = package.loadlib(path,"luaopen_socket")
通常使用require来加载C程序库，这个函数会搜索指定的库，然后用loadlib来加载库，并返回初始化函数。

8.3 错误
由于Lua是一种扩展语言，通常嵌入在应用程序中，因此在发生错误时它不能简单地崩溃或退出。
通过调用err函数并传入一个错误消息的参数。
由于像if not <condition> then error end这样的组合是非常通用的代码，所以Lua提供了一个内建函数assert来完成此工作。
当一个函数遭遇了一种未预期的状况，它可以采取两种基本的行为：返回错误代码或引发一个错误。
易于避免的异常应该引发一个错误，否则应返回错误代码。

8.4 错误处理与异常
如果需要在Lua中处理错误，则必须使用函数pcall来包装需要执行的代码。

8.5 错误消息与追溯
Lua提供了函数xpcall，该函数除了接受一个需要被调用的函数外，还接受第二个参数--一个错误处理函数。
可以使用debug.traceback函数获取当前执行的调用栈。






















