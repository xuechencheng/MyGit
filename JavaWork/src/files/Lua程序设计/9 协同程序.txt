第9章 协同程序
一个具有多个协同程序的程序在任意时刻只能运行一个协同程序，并且正在运行的协同程序只会在其显示地要求挂起时，它的执行才会暂停。

9.1 协同程序基础
Lua将所有关于协同程序的函数放置在一个名为“coroutine”的table中。
函数create用于创建新的协同程序，它只有一个参数，就是一个函数。
create会返回一个thread类型的值，用以表示新的协同程序，通常create的参数是一个匿名函数。
一个协同程序具有4种不同的状态：挂起，运行，死亡和正常。
当创建一个协同程序时，它处于挂起状态。
可以通过函数status来检查协同程序的状态。
函数coroutine.resume用于启动或再次启动一个协同程序的执行，并将其状态由挂起改为运行。
函数yield可以让一个运行中的协同程序挂起，而之后可以再恢复它的运行。
当一个协同程序A唤醒另一个协同程序B，协同程序A进入“正常”状态。
Lua的协同程序还具有一项有用的机制，就是可以通过一对resume-yield来交换数据。
在第一次调用resume时，并没有对应的yield在等待它，因此所有传递给resume的额外参数都将视为协同程序主函数的参数。
co = coroutine.create(function(a,b,c) print("co",a,b,c) end)
coroutine.resume(co,1,2,3)
与此对应的是，yield返回的额外直就是对应resume传入的参数。
当一个协同程序结束时，它的主函数所返回的值都将作为对应resume的返回值。

9.2 管道与过滤器
一个关于协同程序的经典示例就是“生产者--消费者”的问题。
编程：消费者驱动的“生产者--消费者”问题
过滤器既是一个消费者又是一个生产者，它唤醒一个生产者促使其产生新值，然后又将变换后的值传递给消费者。
编程：添加一个过滤器，在每行起始处插入一个行号。

9.3 以协同程序实现迭代器
编程：写一个迭代器，使其可以遍历某个数组的所有排列组合形式

9.4 非抢先式的多线程
协同程序提供了一种协作式的多线程。每个协同程序都等于是一个线程。一对yield-resume可以将执行权在不同的线程之间切换。
协同程序与常规的多线程不同之处在于，协同程序是非抢先试的。
当一个协同程序运行时，是无法从外部停止它的，只有当协同程序显示地要求挂起时，它才会停止。
对于非抢先式的多线程来说，只要有一个线程调用了一个阻塞的操作，整个程序在该操作完成前，都会停止下来。
编程：多线程下载多个文件







