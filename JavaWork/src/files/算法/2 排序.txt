2.1 初级排序算法
2.1.1 游戏规则
编程：排序算法类的模版
less,exch,show,issorted方法
排序算法的额外内存开销和运行时间是同等重要的。
不需要额外内存的称为原地排序算法。

2.1.2 选择排序
首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置。再次，在剩下的元素中找到最小的元素，如此往复。
N的平方/2次比较和N次交换。
编程：选择排序

2.1.3 插入排序
为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。
对于随机排列的长度为N且主键不重复的数组，平均情况下插入排序需要N的平方/4次比较和交互。最坏情况N平方/2次比较和交互。最好情况需要N-1次比较，0次交换。
事实上，当倒置的数量很少时，插入排序很可能比本章中的其他任何算法都要快。
插入排序对于部分有序的数组十分高效，也很适合小规模数组。而且它也是高级排序算法的中间过程。

2.1.4 排序算法的可视化

2.1.5 比较两种排序算法

2.1.6 希尔排序
希尔排序为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组进行排序。
希尔排序的思想是使数组中任意间隔为h的元素都是有序的。这样的数组称为h有序数组。
透彻了解希尔排序的性能纸巾仍然是一项挑战。
编程：希尔排序
和选择排序以及插入排序形成对比的是，希尔排序可以用于大型数组。
希尔算法在最坏的情况下算法2.3比较次数和N的3/2次方成正比。
对于中等大小的数组，希尔排序的运行时间是可以接受的。它的代码量很小，且不需要外的内存空间。

2.2 归并排序
2.2.1 原地归并的抽象方法
归并，将两个有序的数组归并成一个更大的有序数组。
要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。
归并能够保证将任意长度为N的数组排序所需时间和NlogN成正比，缺点是需要的额外空间和N成正比。
实现归并的一种直截了当的办法是将两个不同的有序数组归并到第三个数组中。
将两个输入数组中的元素一个个从小到大放入第三个数组中。
编程：原地归并的抽象方法
2.2.2 自顶向下的归并排序
编程：自顶向下的归并排序
对于长度为N的任意数组，自顶向下的归并排序需要1/2NlgN至NlgN次比较。
归并排序所需的时间和NlgN成正比。
对小规模数组使用插入排序。
使用插入排序处理小规模的子数组（比如长度小于15）一般可以将归并排序的运行时间缩短10%-15%。
添加一个判断条件，如果a[mid]小于等于a[mid+1]，我们就认为数组已经是有序的并跳过merge方法。
三个改进归并排序的方法：1，对小规模数组使用插入排序；2，测试数组是否已经有序；3，不将元素复制到辅助数组
2.2.3 自底向上的归并排序
递归实现的归并排序是算法设计中分治思想的典型应用。我们将大问题分割成小问题分别解决，然后用所有小问题的答案解决大问题。
实现归并排序的另一种方法是先归并那些微型数组，然后再成对归并得到的子数组，如此这般，直到我们将整个数组归并在一起。
首先我们进行的是两两归并，然后四四归并，八八归并……
编程：自底向上的归并排序
自底向上的归并排序比较适合用链表组织的数据。
2.2.4 排序算法的复杂度
没有任何基于比较的算法能够保证使用少于lg(N!)-NlgN次比较将长度为N的数组排序。

2.3 快速排序
2.3.1 基本算法
快速排序可能是应用最广泛的排序算法。
快速排序使用原地排序，只需要一个很小的辅助栈，且消耗时间和NlgN成正比。
快速排序的缺点是非常脆弱，在实现时要非常小心才能避免低劣的性能。许多错误都能致使它在实际中的性能有平方级别。
快速排序是一种分治的排序算法，它将数组分成两个子数组，将两部分独立地排序。
编程：快速排序
2.3.2 性能特点
归并排序和希尔排序一般都比快速排序慢，其原因就是它们还在内循环中移动数据。
2.3.3 算法改进
1，切换到插入排序
	对于小数组，快速排序比插入排序慢
2，三取样切分
	使用子数组的一小部分元素的中位数来切分数组。
3，熵最优的排序
	改进大量重复元素的数组。
	一个简单的想法是将数组切分为三个部分，分别对应小于、等于和大于切分元素的数组元素。
	编程：三向切分的快速排序（了解）

2.4 优先队列
2.4.1 API
支持删除最大元素和插入元素的数据类型叫做优先队列。
通过插入一列元素然后一个个地删除掉其中最小的元素，我们可以用优先队列实现排序算法，这种算法称为堆排序。
优先队列MaxPQ的主要接口是delMax和insert。
2.4.2 初级实现
数组实现（无序）
	insert方法的代码和栈的push方法完全一样，要实现删除最大元素，使用类似选择排序的代码，将最大元素和边界元素交换然后删除它。
数组实现（有序）
	将所有较大的元素向右移动一格以使数组保持有序。
链表表示法
	可以选择修改pop来找到并返回最大元素，或是修改push来保证所有元素为逆序并用pop来删除并返回链表的首元素。
	使用无序序列是解决这个问题的惰性方法，使用有序序列则是解决问题的积极方法。
2.4.3 堆的定义
当一棵二叉树的每个节点都大于等于它的两个子节点时，它被称为堆有序。
根节点是堆有序的二叉树中最大的节点。
完全二叉树只用数组而不需要用指针就可以表示。将二叉树的节点按照层级顺序放入数组中，根节点在位置1，它的子节点在位置2，3，以此类推。
二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储（不使用数组的第一个位置）。
在一个堆中，位置k的节点的父结点的位置为k/2，而它的两个子节点的位置则分别为2k和2k+1。
一棵大小为N的完全二叉树的高度为lgN。

2.4.4 堆的算法
我们用长度为N+1的私有数组来表示一个大小为N的堆，我们不会使用pg[0]。
堆的操作会首先进行一些简单的改动，打破堆的状态，然后再遍历堆并按照要求将堆的状态恢复。这个过程叫做堆的有序化。
由下至上的堆有序化（上浮）：
	如果堆的有序状态因为某个结点变得比它的父结点更大而被打破，那么我们就需要通过交换它和它的父结点来修复堆。
由上而下的堆有序化（下沉）：
	通过将它和两个子节点中的较大者交换来恢复堆。
插入元素：将新元素加到数组末尾，增加堆的大小并让这个新元素上浮到合适的位置。
删除最大元素：我们从数组顶端删去最大的元素并将数组的最后一个元素放到顶端，减小堆的大小并让这个元素下沉到合适的位置。
插入元素和删除最大元素这两个操作的用时和队列的大小成对数关系。
编程：基于堆的优先队列
对于一个含有N个元素的基于堆的优先队列，插入元素操作只需不超过lgN+1次比较，删除最大元素的操作需要不超过2lgN次比较。
多叉堆：基于数组表示的完全三叉树构造堆并修改相应的代码并不困难。甚至对于给定的d，将其修改为任意的d叉树也并不困难。

2.4.5 堆有序
我们可以把任意优先队列变成一种排序方法。
堆排序可以分为两个阶段：在堆的构造阶段，我们将原始数组重新组织安排进一个堆中；然后在下沉阶段，我们从堆中按递减顺序取出所有元素并得到排序结果。
堆的构造：只需从左向右遍历数组，用swim保证扫描指针左侧的所有元素已经是一棵堆有序的完全树即可。
更聪明高效的办法是从右至左用sink函数构造子堆。
编程：堆排序
将N个元素排序，堆排序只需少于(2NlgN+2N)次比较（以及一半次数的交换）。
堆排序需要恒定的额外空间，当空间十分紧张的时候（例如在嵌入式系统）它很流行。
但现代系统的许多应用中很少使用它，因为它无法利用缓存。数组元素很少和相邻的其他元素进行比较，因此缓存未命中次数要远远高于大多数算法。

2.5 应用
2.5.1 将各种数据排序
如果一个排序算法能够保留数组中重复元素的先对位置则可以称为是稳定的。

2.5.2 我应该使用哪种排序算法
参考文档：各种排序算法的性能特点
快速排序是最快的通用排序算法。
如果稳定性很重要而空间又不是问题，归并排序可能是最好的。
快速排序分为两种：快速排序和三向快速排序
Java的Arrays.sort()使用的是三向快速排序和归并排序。

2.5.3 问题的规约
规约指的是为解决某个问题而发明的算法正好可以用来解决另一个问题。

2.5.4 排序应用一览





















































