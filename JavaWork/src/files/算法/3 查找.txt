3.1 符号表
符号表最主要的目的就是将一个键和一个值联系起来。
符号表是一种存储键值对的数据结构，支持两种操作：插入和查找。
3.1.1 API
每个键只对应一个值（表中不允许存在重复的键）
删除的实现有两种方法：延时删除，也就是将键对应的值置为空，然后在某个时候扇区所有值为空的键，或是即时删除，立刻从表中删除指定的键。
3.1.2 有序符号表
典型的应用程序中，键都是Comparable的对象，因此可以使用a.compareTo(b)来比较a和b两个键。
3.1.3 用例举例
3.1.4 无序链表中的顺序查找
符号表中使用的数据结构的一个简单选择是链表，每个节点存储一个键值对。
get的实现即为遍历链表，put的实现也是遍历链表。
编程：顺序查找（基于无序链表）
向一个空表中插入N个不同的键需要~N平方/2次比较。
3.1.5 有序数组中的二分查找
它使用的数据结构是一对平行的数组，一个存储键一个存储值。
编程：二分查找（基于有序数组）
3.1.6 对二分查找的分析
二分查找减少了比较的次数但无法减少运行所需时间，在键是随机排列的情况下，构造一个基于有序数组的符号表所需要访问数组的次数是数组长度的平方级别。
向一个大小为N的有序数组中插入一个新的元素在最坏情况下需要访问~2N次数组，因此像一个空符号表中插入N个元素在最坏情况下需要访问~N平方次数组。
3.1.7 预览
二分查找平均情况下的成本，查找为lgN，插入为N。
参考文档：符号表的各种实现的优缺点

3.2 二叉查找树
使用每个节点含有两个链接（链表中每个节点只含有一个链接）的二叉查找树来高效的实现符号表，这也是计算机科学中最重要的算法之一。
在二叉树中，每个节点只能有一个父节点（根节点没有父节点），而且每个节点都只有左右两个链接，分别指向自己的左子节点和右子节点。
我们可以将每个链接看做指向了另一棵二叉树，而这棵树的根节点就是被指向的结点。
一棵二叉查找树是一棵二叉树，其中每个结点都含有一个Comparable的键（以及相关的值）且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键。
3.2.1 基本实现
变量N给出了以该结点为根的子树的结点总数。
size(x) = size(x.left) + size(x.right) + 1;
一棵二叉查找树代表了一组键值的集合，而一个集合可以用多棵不同的二叉查找树表示。
编程：基于二叉查找树的符号表
3.2.2 分析
在由N个随机键构造的二叉查找树中，查找命中平均所需的比较次数为~2lnN（约1.39lgN）
在由N个随机键构造的二叉查找树中插入操作和查找未命中平均所需的比较次数为~2lnN（约1.39lgN）。
3.2.3 有序性相关的方法与删除操作
编程：实现其余接口
在一棵二叉查找树中，所有操作在最坏情况下所需的时间都和树的高度成正比。

3.3 平衡查找树
3.3.1 2-3查找树
我们将一棵标准的二叉查找树中的结点称为2-结点（含有一个键和两条链接），而现在我们引入3-结点，它含有两个键和三个结点。
一棵2-3查找树或为一棵空树，或由以下结点组成：
2-结点，含有一个键和两条链接，左链接指向2-3树中的键都小于该结点，右链接指向的键都大于该结点。
3-结点，含有两个键和三条链接，左连接和右链接同上，中链接指向2-3树中的键都位于该结点的两个键之间。
一棵完美平衡的2-3查找树中的所有空链接到根节点的距离都应该是相同的。简洁起见，这里我们用2-3树指代一棵完美平衡的2-3查找树。
插入新键：如果未命中的查找结束于一个2-结点，我们把2-结点替换为3-结点，将要插入的键保存在其中即可。
向一棵只含有一个3-结点的树中插入新键：
1，假设我们需要向一棵只含有一个3-结点的树中参入一个新键，我们先临时创建一个4-结点，然后转换为一棵由3个2-结点组成的2-3树；
2，假设未命中的查找结束于一个3-结点，而它的父结点是一个2-结点。我们先临时创建一个4-结点，然后将中键移动到原来的父结点，父结点变成3-结点
3，假设未命中的查找结束于一个父结点为3-结点的结点。我们一直向上不断分解临时的4-结点，直到遇到一个2-结点并将它替换为一个不需要继续分解的3-结点，或者到达3-根节点。
将一个4-结点分解为一棵2-3树可能有6种情况，这个4-结点可能是根节点，可能是一个2-结点的左子节点或右子节点，也可能是一个3-结点的左，中，右子节点。
在一棵大小为N的2-3树中，查找和插入操作访问的结点必然不超过lgN个。
含有10亿个结点的一棵2-3树的高度仅在19到30之间，我们最多只需要访问30个结点就能够在10亿个键中进行任意查找和插入操作，这是相当惊人的。
尽管我们可以用不同的数据类型表示2-结点和3-结点并写出变换所需的代码，但用这种直白的表示方法实现大多数操作并不方便，因为需要处理的情况太多了。

3.3.2 红黑二叉查找树
我们将树中的链接分为两种类型：红链接将两个2-结点连接起来构成一个3-结点，黑链接则是2-3树中的普通链接。
确切的说，我们将3-结点表示为由一条左斜的红色链接（两个2-结点其中之一是另一个的左子节点）相连的两个2-结点。
这种表示法的一个优点是，我们无需修改就可以直接使用标准二叉查找树的get()方法。
对于任意2-3树，只要对结点进行转换，我们都可以立即派生出一棵对应的二叉查找树。
我们将用这种方式表示2-3树的二叉查找树称为红黑二叉查找树，简称红黑树。
红黑树的另一种定义是含有红黑链接并满足下列条件的二叉查找树：
1，红链接均为左链接；
2，没有任何一个结点同时和两条红链接相连；
3，该树是完美黑色平衡的；
满足这样定义的红黑树和相应的2-3树是一一对应的。
如果我们将一棵红黑树中的红链接画平，那么所有的空链接到根节点的距离都是相同的。
红黑树能够将两个算法的优点结合起来：二叉查找树中简洁高效的查找方法和2-3树中高效的平衡插入算法。
当我们提到一个结点的颜色时，我们指的是该结点的链接的颜色。
在我们实现的某些操作中可能会出现红色右链接或者两条连续的红链接，但在操作完成前这些情况都会被小心地旋转并修复。
假设我们有一条红色的右链接需要被转化为左链接，这个操作叫做左旋转。
无论左旋转还是右旋转，旋转操作都会返回一条链接。我们总是会用rotateRight()或rotateLeft()的返回值重置父节点（或根节点）中相应的链接。
返回的链接可能是红色也可能是黑色，这可能会产生两条连续的红链接，但我们的算法会继续用旋转操作修正这种情况。
在插入新的键时，我们可以使用旋转操作帮助我们保证2-3树和红黑树之间的一一对应关系，因为旋转操作可以保持红黑树的两个重要性质：有序性和完美平衡性。
1，向单个2-结点中插入新键
一棵只含有一个键的红黑树只含有一个2-结点。插入另一个键，如果新键小于老键，我们只需要新增一个红色结点即可。
如果新键大于老键，那么新增的红色结点将会产生一条红色的右链接，我们需要将其旋转为红色左链接并修正根节点的链接，插入操作才算完成。
2，向树底部的2-结点插入新键
向一棵红黑树中插入一个新键会在树的底部新增一个结点，但总是用红链接将新节点和它的父结点相连。
如果它的父结点是一个2-结点，那么刚才的两种处理方法仍然适用。如果指向新节点的是父结点的左链接，那么父结点就直接成为了一个3-结点。
如果指向新节点的是父结点的右链接，这就是一个错误的3-结点，但一次左旋转就能够修正它。
3，向一个3-结点中插入新键
这种情况又可分为三种子情况：新键小于树中的两个键，在两者之间，或是大于树中的两个键。
每种情况都会产生一个同时连接到两条红链接的结点，而我们的目标就是修正这一点。
1，新键大于原树中的两键，因此它被链接到3-结点的右链接。此时，有两条红链分别和较大和较小的结点相连。我们将两条链接的颜色由红变黑即可。
2，如果新键小于原树中的两个键，它会被连接到最左边的空链接，这样就产生了两条连续的红链接。此时我们只需要将上层的红链接右旋转即可得到第一种情况。
3，如果新键介于原树中的两个键之间，这会产生两条连续的红链接，一条红色左连接接一条红色右链接。我们需要将下层红链接左旋转即可得到第二种情况。
总的来说，我们通过0次，1次和2次旋转以及颜色的变化得到了期望的结果。
颜色转换：除了将子节点的颜色由红变黑之外，我们同时还要将父结点的颜色由黑变红。不会影响整棵树的黑色平衡性。
根节点总是黑色：颜色转换会使根节点变为红色。
严格地说，红色的根节点说明根节点是一个3-结点的一部分，但实际情况并不是这样。我们在每次插入后都会将根节点设为黑色。
每当根节点由红变黑时树的黑链接高度就会加1。
每次必要的旋转之后，我们都会进行颜色转换，这使得中结点变红。在父结点看来，处理这样一个红色结点的方式和处理一个新插入的红色结点完全相同，即继续把红链接转移到中结点上去。
总之，只要谨慎地使用左旋转，右旋转和颜色转换，我们就能够保证插入操作后红黑树和2-3树的一一对应关系。
在沿着插入点到根节点的路径向上移动时在所经过的每个结点中顺序完成以下操作，我们就能完成插入操作：
1，如果右子节点是红色的而左子节点是黑色的，进行左旋转；
2，如果左子节点是红色的且它的左子节点也是红色的，进行右旋转；
3，如果左右子节点均为红色，进行颜色转换。

3.3.3 实现
编程：红黑树的插入算法

3.3.4 删除操作
put()方法是本书中最复杂的实现之一，而红黑树的deleteMin(),deleteMax()和delete()的实现更麻烦。
（待续）


3.3.5 红黑树性质
所有基于红黑树的符号表实现都能保证操作的运行时间为对数级别。
一棵大小为N的红黑树的高度不会超过2lgN。
一棵大小为N的红黑树中，根节点到任意结点的平均路径长度为~1.001lgN。
在信息世界的汪洋大海中，表的大小可能上千亿，但我们仍能确保在几十次比较之内就完成这些操作。


3.4 散列表
使用散列的查找算法分为两步：1，用散列函数将被查找的键转化为数组的一个索引；2，处理碰撞冲突
散列表是算法在时间和空间上做出权衡的经典例子。
使用散列表，你可以实现在一般应用中拥有（均摊后）常数级别的查找和插入操作的符号表。
这使得它在很多情况下成为实现简单符号表的最佳选择。

3.4.1 散列函数
我们要找的散列函数应该易于计算并且能够均匀分布所有的键，即对于任意键，0到M-1之间的每个整数都有相等的可能性与之相关（与键无关）。
散列函数和键的类型有关。严格地说，对于每种类型的键我们都需要一个与之对应的散列函数。
正整数：
	将整数散列最常用方法是除留余数法。选择大小为素数M的数组，对于任意正整数k，计算k除以M的余数。
浮点数：
	如果键是0到1之间的实数，我们可以将它乘以M并四舍五入得到一个0至M-1之间的索引值。
	或者将键表示为二进制数然后再使用除留余数法。
字符串：
	除留余数法也可以处理较长的键，例如字符串，我们只需将它们当作大整数即可。
组合键：
	如果键的类型含有多个类型变量，我们可以和String类型一样将它们混合起来。
Java约定每一种数据类型的hashCode()方法都必须和equals()方法一致。
Java为很多常用的数据类型重写了hashCode方法（包括String,Integer,Double,File和URL），默认散列函数会返回对象的内存地址。
要为一个数据类型实现一个优秀的散列方法需要满足三个条件：一致性，高效性和均匀性

3.4.2 基于拉链法的散列表
碰撞处理也就是处理两个或多个键的散列值相同的情况。
一种方法是将大小为M的数组中的每个元素都指向一条链表，链表中的每个结点都存储了散列值为该元素的索引的键值对。这种方法称为拉链法。
拉链法的一种实现方法是使用原始的链表数据类型，另一种更简单的方法（效率稍低），为M个元素分别构建符号表来保存散列到这里的键。
编程：基于拉链法的散列表
在一张含有M条链接和N个键的散列表中，任意一条链表中的键的数量均在N/M的常数因子范围内的概率无限趋向于1.
在一张含有M条链接和N个键的散列表中，未命中查找和插入操作所需的比较次数为~N/M。
在键的顺序并不重要的应用中，拉链法可能是最快的符号表实现。

3.4.3 基于线性探测法的散列表
实现散列表的另一种方式就是用大小为M的数组保存N个键值对，其中M>N。我们需要依靠数组中的空位解决碰撞冲突。基于这种策略的所有方法称为开发地址散列表。
开发地址散列表中最简单的方法叫做线性探测法。当发生碰撞时，我们直接检查散列表中的下一个位置。
我们用散列函数找到键在数组中的索引，检查其中的键和被查找的键是否相同。如果不同则继续查找，直到找到该键或者遇到一个空元素。
编程：基于线性探测的符号表
删除操作：
如何从基于线性探测的散列表中删除一个键？直接将该键所在的位置设为null是不行的，因为这会使得此位置之后的元素无法被查找。
我们需要将簇中被删除键的右侧的所有键重新插入散列表。
编程：删除元素
a是表中已被占用空间的比例，它是不可能大于1的。为了保证性能，我们会动态调整数组大小保证使用率在1/8到1/2之间。
线性探测的平均成本取决于元素在插入数组后聚集成的一组连续的条目，叫做键簇。
在一张大小为M并含有N=aM个键的基于线性探测的散列表中，基于假设J，命中和未命中的查找所需的探测次数分别为：
~1/2(1+1/(1-a))和~1/2(1+1/(1-a)的平方)
当散列表快满的时候查找所需的探测次数是巨大的，当使用率小于1/2时探测的预计次数在1.5到2.5之间。为此，我们考虑动态调整散列数组的大小。

3.4.4 调整数组大小
编程：调整线性探测散列表

3.4.5 内存使用

3.5 应用
3.5.1 我应该使用符号表的哪种实现
参考文档：各种符号表实现的渐进性能的总结
对于典型的应用程序，应该在散列表和二叉查找树之间进行选择。
根据经验法则，大多数程序员的第一选择都是散列表，在其他因素更重要时才会选择红黑树。
3.5.2 集合的API
只要忽略键关联的值或者使用一个简单的类进行封装，你就可以将任何符号表的实现变成一个SET类的实现。
我们在用例中使用SET表示有序的集合，用HashSET表示无序的集合。
3.5.3 字典类用例
3.5.4 索引类用例
3.5.5 稀疏向量（待续）































