1.1 基础编程模型
编程：求两个非负整数的最大公约数
数据结构是算法的副产品或是结果，因此要理解算法必须学习数据结构。
e是10的次方
编写递归代码时最重要的有以下三点：
	递归总有一种最简单的情况，方法的第一条语句总是一个包含return的条件语句。
	递归调用总是去尝试解决一个规模更小的子问题，这样递归才能收敛到最简单的情况。
	递归调用的父问题和尝试解决的子问题之间不应该有交集。
编程：随机将double数组中的元素排序
编程：二分查找

1.2 数据抽象
当我们将数组传递给一个方法或是将一个数组变量放在赋值语句右侧时，我们都是在创建该数组引用的一个副本，而非数组的副本。

1.3 背包，队列和栈
1.3.1 API
背包是一种不支持从中删除元素的集合数据类型。迭代的顺序不确定且与用例无关。
先进先出队列或简称队列，是一种基于先进先出策略的集合类型。
下压栈是一种基于后进先出策略的集合类型。
编程：计算算术表达式（表达式每次运算都包含括号）
	Dijkstra算法，用两个栈，一个用于保存运算符，一个用于保存操作数。
	将操作数压入栈；将运算符压入栈；忽略左括号；在遇到右括号时，弹出一个运算符，弹出所需数量的操作数，并将运算结果压入栈。

1.3.2集合类数据类型的实现

编程：下压栈的完整实例（能够动态调整数组大小的实现）
	压栈，出栈
	调整数组大小，push时候，如果没有多余的空间，我们会将数组的长度加倍，pop时，如果栈大小小于数组的四分之一，将数组长度减半。
	支持迭代
		要使一个类可迭代，第一步就是在它的声明中加入implements Iterable<Item>对应的接口为Iterator<Item> iterator();
		迭代器是一个实现了hasnext和next方法的类的对象。可以把迭代器声明为一个嵌套类。

1.3.3链表
链表是一种递归的数据结构，它或者为空，或者是指向一个结点的引用，该结点含有一个泛型的元素和一个指向另一条链表的引用。
private class Node{Item item; Node next;}
在链表中比较容易实现的操作：
	在表头插入结点；从表头删除结点；在表尾插入结点。
不容易实现的操作：
	删除指定的结点；在指定结点前插入一个新结点
实现任意插入和删除操作的标准解决方案是使用双向链表。

编程：下压堆栈（链表实现）
编程：先进先出队列（用链表实现）
在结构化存储数据集时，链表是数组的一种重要的替代方式。
编程：背包的实现
数组和链表分别称为顺序存储和链式存储。

1.4 算法分析
1.4.1 科学方法
1.4.2 观察
我们重点研究如何更好的将问题规模和运行时间的关系量化。
编程：统计一个文件中所有和为0的三整数元组的数量。
	使用stopwatch打印运行时间
	产生一系列随机输入数组，在每一步中将数组长度加倍，并打印ThreeSum.count()处理每种输入规模所需的运行时间。
1.4.3 数学模型
1.4.4 增长数量级的分类
增长数量级：常数级别，对数级别，线性级别，线性对数级别，平方级别，立方级别和指数级别
执行最频繁的指令决定了程序执行的总时间，很多程序运行时间都只取决于其中的一小部分指令。
平方级别，立方级别和指数级别的算法对于大规模的问题是不可用的。
在本书中我们希望为各种基础问题找到对数级别，线性级别和线性对数级别的算法。
1.4.5 设计更快的算法
编程：改进2-sum算法。
改进2-sum的方法，当且仅当-a[i]存在于数组中时，a[i]存在于某个和为0的整数对之中。使用binarySearch的rank方法对-a[i]进行二分查找。
归并排序所需的时间和NlogN成正比，二分查找所需时间和logN成正比。
3-sum改进方法类似，改进后的总运行时间和N平方*logN成正比。
1.4.6 倍率实验
对于编写的每个程序，你都要能够回答这个基本问题：“该程序能在可接受的时间内处理这些数据吗？”。
1.4.7 注意事项
1.4.8 处理对于输入的依赖
1.4.9 内存
分析内存的使用比分析程序所需的运行时间要简单得多。
1.4.10 展望
在编程领域中，最常见的错误或许就是过于关注程序的性能。第二常见的错误或许是完全忽略了程序的性能。

1.5 案例研究：union-find算法
1.5.1 动态连通性
编程：动态连通性问题
当程序从输入中读取了整数对p和q时，如果已知的所有整数对都不能说明p和q是相连的，那么则将这一对整数写入到输出中。
定义分量类UF和union(),find(),connected()和count()方法。
1.5.2 实现
quick-find算法：UF包含一个数组，一种方法是保证当且仅当id[p]等于id[q]时p和q是连通的。
如果id[p]和id[q]不同时，需要遍历整个数组，将所有和id[q]相等的值变为id[p]的值。
quick-find无法处理大型问题，因为对于每一对输入union()都需要扫描整个id[]数组。

quick-union算法
编程：quick-union算法实现
每个触点所对应的id[]元素都是同一个分量中的另一个触点的名称（也可能是它自己），我们将这种联系称为链接。
find方法寻找到根触点，即链接指向自己的触点。
当且仅当分别由两个触点开始的这个多层到达同一个根触点时，它们存在于同一个连通分量中。
union很简单，只需要将一个根触点链接到另一个根触点即可。因此这个算法叫quick-union。
id[]用父链接的方式表示了一片森林。

加权quick-union算法
编程：quick-union算法实现
记录每一棵树的大小并总是将较小的树连接到较大的树上。我们称它为加权算法。
quick-union算法能够保证对数级别的性能。
对于N个触点，加权quick-union算法构造的森林中的任意结点的深度最多为lgN。
路径压缩的加权quick-union算法是最优的算法。

1.5.3 展望























































































	
	
	
	


























