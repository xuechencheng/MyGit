长整型和扩展进度浮点型：long long和long double
可寻址的最小内存块称为字节，存储的基本单元称为字，通常由几个字节组成。字节通常由8比特组成，字由4或8个字节组成。
整型可以划分为带符号的和无符号的。
unsigned int可以缩写为unsigned。
字符被分为三种类型：char，signed char和unsigned char。
8比特的unsigned char表示0到255内的值，sign char表示-128到127。
一般使用int进行运算，如果超过int范围请使用long long类型。
执行浮点数预算选用double，long double提供的精度在一般情况下没有必要，而且运行时消耗不容忽视。
如果i为0，则条件的值为false，i为非0值条件为true。
当一个算术表达式中即有无符号又有int值时，那个int值就会转换成无符号数。
当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是负数。
0开头的整数代表八进制，0x开头代表十六进制。
默认的浮点型字面值是一个double。
编译器在每个字符串的结尾处添加空字符('\0')，因此字符串字面值的实际长度要比它的内容多1。
整型字面值后缀ll或LL表示long long，浮点型后缀l表示long double
定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显示地初始化，则其值由类确定。
声明使得名字为程序所知，而定义负责创建于名字关联的实体。
如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显示地初始化变量。
引用为对象起了另外一个名字。引用并非对象。一旦定义了引用，就无法令其再绑定到另外的对象。
因为引用本身不是对象，所以不能定义引用的引用。
指针本身也是一个对象，允许对指针复制和拷贝。
指定空指针的方法：int *p1 = nullptr; =0; = NULL;
void*是一种特殊的指针类型，可用于存放任意对象的地址。
指向指针的引用 int *p; int *&r = p;
const对象一旦创建后其值就不能再改变，所以const对象必须初始化。
const对象如果要在多个文件中共用，不管是声明还是定义都要添加extern关键字。
对const的引用可能引用一个并非const的对象。
类似于常量引用，指向常量的指针不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针。
所谓指向常量的指针和引用，不过是指针或引用“自以为是”，觉得自己指向了常量。
允许把指针本身定为常量，常量指针必须初始化，它的值（存放在指针中的地址）就不能再改变了。int *const curErr = &errNumb;
const double *cptr和double *const cptr的区别。
指针本身是一个对象，他又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指的是不是常量就是两个独立的问题。顶层const表示指针本身是一个常量，底层const表示指针所指对象时一个常量。
常量表达式是指不会改变并且在编译过程就能得到计算结果的表达式。
声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。
类型别名是一个名字，它是某种类型的同义词。有两种方法用于定义类型别名，传统的方法使用关键字typedef，新方法是使用using。
auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。
decltype的作用是选择并返回操作数的数据类型。在此过程中，并不实际计算表达式的值。
很多新手程序员经常忘了在类定义的最后加上分号。
头文件通常包含那些只能被定义一次的实体，如类，const和constexpr变量等。
确保头文件多次包含仍能安全工作的常用技术是预处理器。
预处理命令：#define #ifdef #ifndef #endif
#ifndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
struct Sales_data{};
#endif
头文件即使没有被包含在任何其他头文件中，也应该设置保护符。头文件保护符很简单，程序员只要习惯性加上就可以了。












