1，定义模版
1.1函数模版
template <typename T>
int compare(const T &v1, const T &v2){}
类型参数前必须使用关键字class或typename，typename和class没什么不同
第一个模版参数表示第一个数组的长度，第二个参数表示第二个数组的长度：
template<unsigned N, unsigned M>
int compare(const char (&p1)[N], const char (&p2)[M]){}
非类型模版参数的模版实参必须是常量表达式。
一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或引用。
编写泛型代码的两个重要原则：1，模版中的函数参数是const的引用；2，函数体中的条件判断仅使用<比较运算

1.2 类模版
template <typename T> class Blob{}
当编译器从我们的Blob模版实例化出一个类时，它会重写Blob模版，将模版参数T的每个实例替换为给定的模版实参。
定义在类模版之外的成员函数就必须以关键字tempalte开始，后接类模版参数列表。
类模版与友元。


1.3 模版参数
就像我们能为函数参数提供默认实参一样，我们也可以提供默认模版实参。
template <typename T,typename F = less<T>>
int compare(const T &v1, const T &v1, F f = F())
与默认实参一样，对于一个模版参数，只有当它右侧的所有参数都有默认实参时，它才可以有默认实参。
模版默认实参与类模版
template <class T = int> class Numbers{};

1.4 成员模版

1.5 控制实例化
在大型系统中，在多个文件中实例化相同模板的额外开销可能非常严重。在新的标准中，可以通过显示实例化来避免这种开销。
extern template class Blob<string>;
template int compare(const int&, const int&);//

1.6 效率与灵活性

2 模版实参推断
2.1 类型转换与模版类型参数

2.2 函数模版显式实参

2.3 尾置返回类型与类型转换
template <typename It>
auto fcn(It beg, It end) -> decltype(*beg){}
脱去引用：auto fcn2(It beg,It end)->typename remove_reference<decltype(*beg)>::type
参考文档：标准类型转换模版

2.4 函数指针和实参推断
当我们用一个函数模版初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模版实参。
template<typename T> int compare(const T&,const T&)
int (*pf1)(const int&, cosnt int&) = compare;
当参数是一个函数模版实例的地址时，程序上下文必须满足：对每个模版参数，能唯一确定其类型或值。

2.5 模版实参推断和引用

2.6 理解std::move

2.7 转发

3 重载与模板

4，可变参数模板
一个可变参数模板就是一个接受可变数目参数的模板函数或模板类。
可变数目的参数被称为参数包，存在两种参数包：模板参数包，表示零个或多个模板参数；函数参数包，表示零个或多个函数参数。
template<typename T,typename... Args>
void foo(const T &t, const Args& ... rest)
Args是一个模板参数包，rest是一个函数参数包
当我们需要知道包中有多少元素时，可以使用sizeof...运算符。sizeof...(Args)

4.1 编写可变参数函数模板
可变参数函数通常是递归的，第一步调用处理包中的第一个实参，然后用剩余实参调用自身。

4.2 包扩展


4.3 转发参数包

5 模板特例化
一个特例化版本就是模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型。
定义函数模板特例化
template <>
int compare(const char* const &p1, const char* const &p2){}
一个特例化版本本质上是一个实例，而非函数名的一个重载版本。因此，特例化不影响函数匹配。
除了特例化函数模板，我们还可以特例化类模板。






























































