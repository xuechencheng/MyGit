1，拷贝，复制与销毁
1.1 拷贝构造函数
拷贝构造函数
	Sales_data::Sales_data(const Sales_data& rhs) {}
拷贝赋值运算符
	Sales_data& Sales_data::operator=(const Sales_data &rhs){}
移动构造函数
	Sales_data::Sales_data(Sales_data&& rhs) noexcept{}
移动赋值运算符
	Sales_data& Sales_data::operator=(Sales_data &&rhs) noexcept{}
析构函数
	Sales_data::~Sales_data()



1.2 拷贝赋值运算符

1.3 析构函数

1.4 三/五法则
需要析构函数的类也需要拷贝和赋值操作。
需要拷贝操作的类也需要赋值操作，反之亦然。

1.5 使用=default
	=default
1.6 阻止拷贝
	=delete
	
2，拷贝控制和资源管理

3，交换操作
	swap函数

4，拷贝控制示例

5，动态内存管理类

6，对象移动（需要重看）
6.1，右值引用
	在某些情况下，对象拷贝后立即被销毁了。在这些情况下，移动而非拷贝对象会大幅度提升性能。
	我们可以通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用。


6.2 移动构造函数和移动赋值运算符
	noexcept
	类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值。
	如果一个类定义了自己的拷贝构造函数，拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。
	只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。
	定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的。

6.3 右值引用和成员函数





































































