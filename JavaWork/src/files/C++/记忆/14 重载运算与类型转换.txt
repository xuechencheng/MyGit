1，基本概念

2，输入和输出运算符
输入输出运算符必须是非成员函数，而不能是类的成员函数。否则，它们的左侧运算对象将是我们的类的一个对象。
ostream &operator<<(ostream &os, const Sales_data &item)
istream &operator>>(istream &is, Sales_data &item)

3，算术和关系运算符
通常情况下，我们把算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。
如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。
如果类定义了operator==，则这个类也应该定义operator!=。
相等运算符和不等运算符中的一个应该把工作委托给另一个。
关联容器和一些算法要用到小于运算符，所以定义operator<会比较有用。

4，赋值运算符
接受花括号内的元素列表作为赋值参数。
StrVec &operator=(std::initializer_list<std::string>);
赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做。

5，下标运算符
下标运算符必须是成员函数。
如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用。
例子：std::string& operator[](std::size_t n)和const std::string& operator[](std::size_t n) const
当StrVec是非常量时，我们可以给元素赋值；而当我们对常量对象取下标时，不能为其赋值。

6，递增和递减运算符
定义递增和递减运算符的类应该同时定义前置版本和后置版本。这些运算符通常应该被定义成类的成员。
后置运算符应该返回对象的原值，返回的形式是一个值而非引用。
StrBlobPtr& operator++();//前置运算符
StrBlobPtr operator++(int)//后置运算符
后置版本接受一个额外的int类型形参。我们无须使用int形参，所以无须为其命名。

7，成员访问运算符
解引用运算符(*)和箭头运算符(->)。
例子：std::string& operator*() const
std::string* operator->() const

8，函数调用运算符
Struct absInt {int operator()(int val) const{}};
int i = -42;absInt absObj;int ui = absObj(i);
如果定义了调用运算符，则该类的对象被称作函数对象。
函数对象常常作为泛型算法的实参，
for_each(vs.begin(), vs.end(), PrintString(cerr,'\n'))

8.1 lambda是函数对象
lambda是函数对象。


8.2 标准库定义的函数对象

8.3 可调用对象与function
下面这些可调用对象，尽管它们的类型各不相同，但是共享一种调用形式：int(int,int)。
	int add(int i, int j){}
	auto mod = [](int i, int j){};
	struct divide{int operator()(int i, int j){}};
可以使用function的新的标准库类型解决上述问题，
	function<int(int,int)> f1 = add;function<int(int,int)> f2 = divede();function <int(int,int)> f3 = [](int i, int j){};
然后定义map：map<string, function<int(int,int)>> binops;

9，重载，类型转换与运算符
9.1 类型转换运算符
类型转换函数的一般形式为operator type() const;
一个类型转换函数必须是类的成员函数。
class SmallInt{
	public:
		operator int() const{return val;}
};
SmallInt si;int num = si + 3;
在实践中，类很少提供类型转换运算符。但是，对于类来说，定义向bool的类型转换还是比较普遍的现象。

9.2 避免有二义性的类型转换

9.3 函数匹配与重载运算符



















