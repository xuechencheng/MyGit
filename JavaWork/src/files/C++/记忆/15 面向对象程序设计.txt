1，OOP：概述
对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明为虚函数。
派生类可以在这样的函数之前加上virtual关键字，但是并不是非得这么做。
C++11新标准允许派生类显示地注明它将使用哪个成员函数改写基类的虚函数，使用ovveride关键字。
在C++语言中，当我们使用基类的引用或指针调用一个虚函数时将发生动态绑定。

2，定义基类和派生类
2.1 定义基类
基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。
成员函数如果没有被声明为虚函数，则其解析过程发生在编译时而非运行时。

2.2 定义派生类
基类三种访问说明符：public，protected或者private。
派生类经常（但不总是）覆盖它继承的虚函数。
每个类控制它自己的成员初始化过程。
可以利用基类的构造函数初始化子类：
Bulk_quote(const string& book,double p,size_t qty,double disc):Quote(book,p),min_qty(qty),discount(disc){}
无论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在一个实例。
在类名后面跟一个关键字final可以防止继承的发生。
class NoDerived final{};

2.3 类型转换与继承
我们可以将基类的指针或引用绑定到派生类对象上。

3，虚函数
动态绑定只有当我们通过指针或引用调用虚函数时才会发生。
我们可以把某个函数指定为final，则之后的任何尝试覆盖该函数的操作都将引发错误。
某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其自信虚函数的某个版本。
double undiscounted = baseP->Quote::net_price(42);

4，抽象基类
和普通的虚函数不一样，一个纯虚函数无须定义。
我们通过在函数体的位置书写=0就可以将一个虚函数说明为纯虚函数。其中=0只能出现在类内部的虚函数说明语句处。
我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。
含有纯虚函数的类是抽象基类。
我们不能创建抽象基类的对象。


5，访问控制与继承
某个类对其继承而来的成员的访问权限受到两个因素影响：一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符。

6，继承中的类作用域
如果派生类希望所有的重载版本对于它来说都是可见的，那么它就需要覆盖所有的版本，或者一个都不覆盖。
一条基类成员函数的using声明语句就可以把函数的所有重载实例添加到派生类作用域中。

7，构造函数与拷贝控制
7.1 虚析构函数
一个基类总是需要析构函数，而且它将析构函数设定为虚函数。
如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义行为。

7.2 合成拷贝控制与继承

7.3 派生类的拷贝控制成员
当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。
class D : public Base{
	public:
		D(const D& d):Base(d)
		D(D&& d):Base(std::move(d))
};

7.4 继承的构造函数
一个类只初始化它的直接基类，出于同样的原因，一个类也只能继承其直接基类的构造函数。

类不能继承默认，拷贝和移动构造函数。
派生类继承其基类构造函数的方式是提供一条注明了直接基类名的using声明语句。
using Disc_quote::Disc_quote//继承Disc_quote的构造函数
通常情况下，using声明语句只是令某个命根子在当前作用域内可见。而当作用于构造函数时，using声明语句将令编译器产生代码。
对于基类的某个构造函数，编译器都生成一个与之对应的派生类构造函数。
这些编译器生成的构造函数形如：derived(parms):base(args){}
例子：Bulk_quote(const string& book,double price,size_t qty,double disc):Disc_quote(book, price, qty, disc){}
和普通成员的using声明不一样，一个构造函数的using声明不会改变该构造函数的访问级别。

8，容器与继承
当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针。（更好的选择是智能指针）

9，文本查询程序再探


















































































