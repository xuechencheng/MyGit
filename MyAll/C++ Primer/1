1，声明和定义
C++ 语言支持"分别编译"。
在文件a.cpp中定义了一个全局函数"void a(){}"，而在文件b.cpp中需要调用这个函数。
文件a.cpp和文件b.cpp并不需要相互知道对方的存在，而是可以分别地对它们进行编译，编译成目标文件之后再链接，整个程序就可以运行了。
这是怎么实现的呢？在文件b.cpp中，在调用"void a()"函数之前，先声明一下这个函数"void a();"就可以了。
这是因为编译器在编译 b.cpp 的时候会生成一个符号表，像 "void a()" 这样的看不到定义的符号，就会被存放在这个表中。
在进行链接的时候，编译器就会在别的目标文件中去寻找这个符号的定义。一旦找到了，程序也就可以顺利地生成了。
简单地说，"声明"只是声明这个符号的存在，"定义"则是把一个符号完完整整地描述出来。
声明告诉编译器，这个符号是在其他文件中定义的，我这里先用着，你链接的时候再到别的地方去找找看它到底是什么吧。
需要注意的是，一个符号，在整个程序中可以被声明多次，但却要且仅要被定义一次。

2，头文件的作用
如果有一个很常用的函数"void f() {}"，在整个程序中的许多.cpp文件中都会被调用，我们就只需要在一个文件中定义这个函数，而在其他的文件中声明这个函数就可以了。
一个函数还好，声明起来也就一句话。但是，如果函数多了，比如是一大堆的数学函数，有好几百个，那怎么办？
头文件便可以发挥它的作用了。
头文件不用被编译。我们把所有的函数声明全部放进一个头文件中，当某一个 .cpp 源文件需要它们时，
它们就可以通过一个宏命令 "#include" 包含进这个 .cpp 文件中，从而把它们的内容合并到 .cpp 文件中去。

3，#include
#include是一个来自C语言的宏命令，它在编译器进行编译之前，即在预编译的时候就会起作用。
#include本身是没有其它任何作用与副功能的，它的作用是把它后面所写的那个文件的内容，完完整整地，一字不改地包含到当前的文件中来。

4，头文件中应该写什么
头文件的作用就是被其他的.cpp包含进去的。它们本身并不参与编译，但实际上，它们的内容却在多个 .cpp 文件中得到了编译。
通过"定义只能有一次"的规则，我们很容易可以得出，头文件中应该只放变量和函数的声明，而不能放它们的定义。
只能在头文件中写形如：extern int a; 和 void f(); 的句子。这些才是声明。
如果写上 int a;或者 void f() {}这样的句子，那么一旦这个头文件被两个或两个以上的 .cpp 文件包含的话，编译器会立马报错。

5，三个例外
一，头文件中可以写const对象的定义。因为全局的const对象默认是没有extern的声明的，所以它只在当前文件中有效。
同时，因为这些.cpp文件中的该对象都是从一个头文件中包含进去的，这样也就保证了这些.cpp文件中的这个const对象的值是相同的，可谓一举两得。同理，static对象的定义也可以放进头文件。

二，头文件中可以写内联函数（inline）的定义。因为inline函数是需要编译器在遇到它的地方根据它的定义把它内联展开的，而并非是普通函数那样可以先声明再链接的（内联函数不会链接），
所以编译器就需要在编译时看到内联函数的完整定义才行。

三，头文件中可以写类（class）的定义。因为在程序中创建一个类的对象时，编译器只有在这个类的定义完全可见的情况下，才能知道这个类的对象应该如何布局，
所以，关于类的定义的要求，跟内联函数是基本一样的。所以把类的定义放进头文件，在使用到这个类的 .cpp 文件中去包含这个头文件，是一个很好的做法。在这里，值得一提的是，
类的定义中包含着数据成员和函数成员。数据成员是要等到具体的对象被创建时才会被定义（分配空间），但函数成员却是需要在一开始就被定义的，这也就是我们通常所说的类的实现。
一般，我们的做法是，把类的定义放在头文件中，而把函数成员的实现代码放在一个 .cpp 文件中。这是可以的，也是很好的办法。不过，还有另一种办法。那就是直接把函数成员的实现代码也写进类定义里面。
在 C++ 的类中，如果函数成员在类的定义体中被定义，那么编译器会视这个函数为内联的。因此，把函数成员的定义写进类定义体，一起放进头文件中，是合法的。
注意一下，如果把函数成员的定义写在类定义的头文件中，而没有写进类定义中，这是不合法的，因为这个函数成员此时就不是内联的了。一旦头文件被两个或两个以上的 .cpp 文件包含，这个函数成员就被重定义了。

6，综诉
.h文件中能包含：
	类成员数据的声明，但不能赋值
	类静态数据成员的定义和赋值，但不建议，只是个声明就好。
	类的成员函数的声明
	类的内联函数的定义
	非类成员函数的声明
	常数的定义：如：constint a=5;
	静态函数的定义
不能包含：
	1，所有非静态变量（不是类的数据成员）的声明
	2， 默认命名空间声明不要放在头文件，using namespace std;等应放在.cpp中，在 .h 文件中使用 std::string

7，头文件中的保护措施
如果头文件中只包含声明语句的话，它被同一个.cpp文件包含再多次都没问题，因为声明语句的出现是不受限制的。
然而，上面讨论到的头文件中的三个例外也是头文件很常用的一个用处。那么，一旦一个头文件中出现了上面三个例外中的任何一个，它再被一个 .cpp 包含多次的话，问题就大了。
因为这三个例外中的语法元素虽然"可以定义在多个源文件中"，但是"在一个源文件中只能出现一次"。
设想一下，如果a.h中含有类 A 的定义，b.h中含有类 B 的定义，由于类B的定义依赖了A，所以 b.h 中也 #include了a.h。现在有一个源文件，它同时用到了类A和类B，在这个源文件中既把 a.h 包含进来了，也把 b.h 包含进来了。
这时，问题就来了：类A的定义在这个源文件中出现了两次！于是整个程序就不能通过编译了。你也许会认为这是程序员的失误――他应该知道 b.h 包含了 a.h ――但事实上他不应该知道。
使用 "#define" 配合条件编译可以很好地解决这个问题。在一个头文件中，通过 #define 定义一个名字，并且通过条件编译 #ifndef...#endif 使得编译器可以根据这个名字是否被定义，再决定要不要继续编译该头文中后续的内容。这个方法虽然简单，但是写头文件时一定记得写进去。



