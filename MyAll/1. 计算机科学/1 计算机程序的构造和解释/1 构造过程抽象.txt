构造过程抽象
1.1 程序设计的基本元素
1.1.1 表达式
Lisp 前缀表示
(+ 137 349)	(+ 12 35 12 7)	(+ (* 3 5) (- 10 6))

1.1.2 命名和环境
命名变量
(define size 2)

1.1.3 组合式的求值
“值向上穿行”形式的求值形式是一类更一般的计算过程的一个例子，这种计算过程称为树形积累。

1.1.4 复合过程
定义平方的复合过程：(define (square x)(* x x))	(square 21)

1.1.5 过程应用的代换模型
解释器首先对运算符和各个运算对象求值，而后将得到的过程应用于得到的实际参数。另一种求值模型是先不求出运算对象的值，直到实际需要它们的值时再去做。
这种“完全展开而后规约”的求值模型称为正则序求值，与之对应的是现在解释器里实际使用的“先求值参数而后应用”的方式，称为应用序求值。
Lisp采用应用序求值。部分原因在于这样做能避免对于表达式的重复求值。更重要的是，在超出了可以采用替换方式模拟的过程范围之后，正则序的处理变得更复杂得多。

1.1.6 条件表达式和谓词
Lisp里有着一种针对这类分情况分析的特殊形式，称为cond。
逻辑复合运算符：and or not

1.1.7 实例：采用牛顿法求平方根
如何计算出平方根？最常用的就是牛顿的逐步逼近方法。
如果对x的平方根的值有一个猜测y，那么就可以通过执行一个简单操作去得到一个更好的猜测：只需求出y和x/y的平均值。
使用递归实现循环的效果。

1.1.8 过程作为黑箱抽象


1.2 过程与它们所产生的计算
1.2.1 线性的递归和迭代
阶乘的两种实现方法：1，递归；2，从1开始乘。
前者的计算过程称为线性递归过程，后者称为迭代计算过程。

1.2.2 树形递归
一种常见计算模式称为树形递归。
斐波那契数序列，每个数都是前两个数之和。
计算斐波那契数序列有两种方法：1，使用树形递归；2，从1开始算
实例：换零钱方式的统计

1.2.3 增长的阶
令n是一个参数，它能作为问题规模的一种度量，令R(n)是一个计算过程在处理规模为n的问题时所需的资源量。

1.2.4 求幂
可以通过连续求平方，以更少的步骤完成乘幂计算。

1.2.5 最大公约数
如果r是a除以b的余数，那么a和b的公约数正好也是b和r的公约数。
任意两个正整数开始，反复执行这种规约，最终产生一个数对，其中的第二个数是0，此时的GCD就是另一个数。这一计算GCD的方法称为欧几里得算法。
欧几里得算法所需的步数是对数增长的。

1.2.6 实例：素数检测
寻找因子：如果不是素数，它必然有一个小于或者等于根号n的因子。因此只需在1和根号n之间检查因子。确定是否素数所需的步数将具有根号n的增长阶。
费马检查：如果n是一个素数，a是小于n的任意正整数，那么a的n次方与a模n同余。

1.3 用高阶函数做抽象

1.3.1 过程作为参数
1，计算从a到b的各整数之和；2，计算给定范围内的整数的立方之和；3，计算1/1x3 + 1/5x7 + ...

1.3.2 用lambda构造过程
一般而言，lambda用与define同样的方式创建过程，除了不为有关过程提供名字之外。

1.3.3 过程为一般性的方法
本节讨论两个更精细的实例：找出函数零点和不动点的一般性方法。
区间折半方法是寻找方程f(x)=0根的一种简单而强有力的方法。
如果对于给定点a和b有f(a)<0<f(b)，那么f在a和b之间必然有一个f的零点。
数x称为函数f的不动点，如果x满足方程f(x)=x。
对于某些函数，通过从某个初始猜测出发，反复地应用f。f(x),f(f(x)),...直到值变化不大，就可以找到它的一个不动点。

1.3.4 过程作为返回值