1，异常处理
待续

2，命名空间
2.1 命名空间定义
多个库将名字放在全局命名空间中将会引发命名空间污染。
命名空间为防止名字冲突提供了更加可控的机制。
命名空间既可以定义在全局作用域内，也可以定义在其他命名空间中。
通常情况下，我们不把#include放在命名空间内部。如果我们这么做了，隐含的意思是把头文件所有的名字定义成该命名空间的成员。
命名空间对于名字的声明必须在作用域内，但可以在命名空间定义的外部订购一该命名空间的成员。
C++11新标准引入了一种新的嵌套命名空间，称为内联命名空间。和普通嵌套命名空间不同，内联命名空间的名字可以被外层命名空间直接使用。
定义内联命名空间的方法是使用关键字namespace前加上关键字inline。
未命名的命名空间中定义的变量拥有静态生命周期；它们在第一次使用前创建，并且直到程序结束才销毁。
和其他命名空间不同，未命名的命名空间仅在特定的文件内部有效，其作用范围不会横跨多个不同的文件。

2.2 使用命名空间成员
命名空间别名：namespace primer = cplusplus_primer;
using声明：一条suing声明语句一次值引入命名空间的一个成员。它使得我们可以清楚地知道程序中所用的到底是哪个名字。

2.3 类，命名空间与作用域
2.4 重载与命名空间

3 多重继承与虚继承
3.1 多重继承
构造一个派生类的对象将同时构造并初始化它的所有基类子对象。
允许派生类从它的一个或几个基类中继承构造函数，但是如果从多个基类中继承相同的构造函数，则发生错误。
如果一个类从它的多个基类中继承了相同的构造函数，则这个类必须为该构造函数定义它自己的版本。
例子见书本

3.2 类型转换与多个基类

3.3 多重继承下的类作用域
当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名成员的情况。此时，不加前缀限定符直接使用改名字将引发二义性。
要想避免二义性，最好的办法是在派生类中为该函数定义一个新版本。

3.4 虚继承
虚继承的目的是令某个类做出声明，承诺愿意共享它的基类。共享的基类子对象称为虚基类。
在这种机制下，无论基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。
虚派生只影响从制订了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。
我们制定虚基类的方式是在派生列表中添加关键字virtual。
class Raccoon: public virtual ZooAnimal{};

3.5 构造函数与虚继承









































