1.1 向量
向量是一种兼具大小和方向的量。
位置对于向量是无关紧要的。

1.1.1 向量与坐标系

1.1.2 左手坐标系和右手坐标系
Direct3D采用的是左手坐标系。
如果我们伸出左手，并拢手指，假设它们指向的是x轴的正方向，再弯曲四指指向y轴的正方向，则最后伸直拇指的方向大约就是z轴的正方向。

1.1.3 向量的基本运算

1.2 长度和单位向量

1.3 点积
两个向量点积为：两向量夹角的余弦值乘以这两个向量的模。
我们称p为向量落在向量n上的正交投影。
如果向量集中的每个向量都是互相正交且皆具单位长度，那么我们就称此集合是规范正交的。

1.4 叉积
只有3D向量的叉积有定义，不存在2D向量叉积。
左手拇指法则：如果伸出左手，使并拢的左手手指指向向量u的方向，再弯曲四指，使之指向向量v的方向，那么最后伸直的大拇指指向的即为叉积结果的方向。
通过叉积也可以进行正交化处理。

1.5 点

1.6 利用DirectXMath库进行向量运算
为了使用DirectXMath库，我们需要向代码添加头文件#include <DirectXMath.h>，而为了一些相关的数据类型还要加入头文件#include <DirectXPackedVector3.h>。

1.6.1 向量类型
在DirectXMath库中，核心的向量类型是XMVECTOR，它将被映射到SIMD硬件寄存器。
typedef __m128 XMVECTOR;
类中的数据成员，建议分别使用XMFLOAT2(2D向量)，XMFLOAT3(3D向量)和XMFLOAT4(4D向量)。
如果直接使用上述这些类型计算，不能充分发挥出SIMD技术的高效特性。还需要将这些类型的实例转换为XMVECTOR类型。
总结一下：
1，局部变量或全局变量用XMVECTOR类型；
2，对于类中的数据成员，使用XMFLOAT2(2D向量)，XMFLOAT3(3D向量)和XMFLOAT4(4D向量)类型；
3，在运算之前，通过加载函数将XMFLOATn类型转换为XMVECTOR类型；
4，用XMVECTOR实例进行运算；
5，通过存储函数将XMVECTOR类型转换为XMFLOATn类型。

1.6.2 加载方法和存储方法
将数据从XMFLOAT3类型中加载到XMVECTOR类型：
XMVECTOR XM_CALLCONV XMLoadFloat3(const XMFLOAT3* pSource) 
将数据从XMVECTOR类型中存储到XMFLOAT3类型
void XM_CALLCONV XMStoreFloat3(XMFLOAT3* pDestination, FXMVECTOR V)
当我们只希望从XMVECTOR实例中得到某一个向量分量或将某一向量分量转换为XMVECTOR类型时：
float XM_CALLCONV XMVectorGetX(FXMVECTOR V);
XMVECTOR XM_CALLCONV XMVectorSetX(FXMVECTOR V,float x);

1.6.3 参数的传递
为了提高效率，可以将XMVECTOR类型的值作为函数的参数，直接传送至SSE/SSE2寄存器里，而不存在栈内。
以此方式传递的参数数量取决于用户使用的平台和编译器。
为了使代码更具通用性，不受具体平台，编译器的影响，我们将利用FXMVECTOR，GXMVECTOR，HXMVECTOR和CXMVECTOR类型来传递XMVECTOR类型的参数。
一定要把调用约定注解XM_CALLCONV加在函数名之前，它会更具编译器的版本确定出对应的调用约定属性。
传递 XMVECTOR参数的规则如下：
1，前3个XMVECTOR参数应当用类型FXMVECTOR；
2，第4个XMVECTOR参数应当用类型GXMVECTOR；
3，第5，6个XMVECTOR参数应当用类型HXMVECTOR；
4，其余的XMVECTOR参数应当用类型CXMVECTOR。
在32位的windows系统上，编译器将根据__fastcall调用约定将前3个XMVECTOR参数传递到寄存器中，而把其余参数都存在栈上。
typedef const XMVECTOR FXMVECTOR;
typedef const XMVECTOR& GXMVECTOR;
typedef const XMVECTOR& HXMVECTOR;
typedef const XMVECTOR& CXMVECTOR;
在32位的windows系统上，编译器将根据__vectorcall调用约定将前6个XMVECTOR参数传递到寄存器中，而把其余参数都存在栈上。
typedef const XMVECTOR FXMVECTOR;
typedef const XMVECTOR GXMVECTOR;
typedef const XMVECTOR HXMVECTOR;
typedef const XMVECTOR& CXMVECTOR;
在编写构造函数时，前3个XMVECTOR参数用FXMVECTOR类型，其余XMVECTOR参数则用CXMVECTOR类型。

1.6.4 常向量
XMVECTOR类型的常量实例应当用XMVECTORF32类型表示。
static const XMVECTORF32 g_vHalfVector = { 0.5f, 0.5f, 0.5f, 0.5f}
XMVECTORF32是一种按16字节对齐的结构体，数学库中还提供了将它转换至XMVECTOR类型的运算符。
也可以通过XMVECTORU32类型来创建由整型数据构成的XMVECTOR常向量。

1.6.5 重载运算符
XMVECTOR类型针对向量的加法运算，减法运算和标量乘法运算都分别提供了对应的重载运算符。

1.6.6 杂项
DirectXMath库定义了一组与π有关的常用数学常量近似值。
另外，它提供了实现弧度和角度间互相转化的内联函数。
DirectXMath库还定义了求出两个数间较大值和较小值的函数。

1.6.7 Setter函数
DirectXMath库提供了下列函数，以设置XMVECTOR类型中的数据。
//返回零向量0
XMVECTOR XM_CALLCONV XMVectorZero();
//返回零向量(1,1,1,1)
XMVECTOR XM_CALLCONV XMVectorSplatOne();
//返回零向量(x,y,z,w)
XMVECTOR XM_CALLCONV XMVectorSet(float x, float y, float z, float w);
//返回零向量(Value,Value,Value,Value)
XMVECTOR XM_CALLCONV XMVectorReplicate(float Value);
//返回零向量(Vx,Vx,Vx,Vx)
XMVECTOR XM_CALLCONV XMVectorSplatX(FXMVECTOR V);
//返回零向量(Vy,Vy,Vy,Vy)
XMVECTOR XM_CALLCONV XMVectorSplatY(FXMVECTOR V);
//返回零向量(Vz,Vz,Vz,Vz)
XMVECTOR XM_CALLCONV XMVectorSplatZ(FXMVECTOR V);

1.6.8 向量函数
DirectXMath库提供了下面的函数来执行各种向量运算。
//返回向量v的模
XMVECTOR XM_CALLCONV XMVector3Length(FXMVECTOR V);
//返回向量v的模的平方
XMVECTOR XM_CALLCONV XMVector3LengthSq(FXMVECTOR V);
//返回向量v1.v2
XMVECTOR XM_CALLCONV XMVector3Dot(FXMVECTOR V1, FXMVECTOR V2);
//返回向量v1xv2
XMVECTOR XM_CALLCONV XMVector3Cross(FXMVECTOR V1, FXMVECTOR V2);
//返回向量v的单位向量
XMVECTOR XM_CALLCONV XMVector3Normalize(FXMVECTOR V);

//返回一个正交于v的向量
XMVECTOR XM_CALLCONV XMVector3Orthogonal(FXMVECTOR V);
//返回向量v1和v2之间的夹角
XMVECTOR XM_CALLCONV XMVector3AngleBetweenVectors(FXMVECTOR V1, FXMVECTOR V2);
//返回projn(v) perpn(v)
void XM_CALLCONV XMVector3Dot(XMVECTOR* pParallel, XMVECTOR* pPerpendicular,FXMVECTOR v, FXMVECTOR Normal);
//返回v1==v2?
bool XM_CALLCONV XMVector3Equal(FXMVECTOR V1, FXMVECTOR V2);
//返回v1!=v2
bool XM_CALLCONV XMVector3NotEqual(FXMVECTOR V1, FXMVECTOR V2);

1.6.9 浮点数误差
为了弥补浮点数精确性上的不足，我们通过比较两个浮点数是否近似相等来加以解决。
在比较时，我们需要定义一个Epsilon常量，它是个非常小的值，可为误差留下一定的缓冲余地。
如果两个数相差小于Epsilon，我们就说这两个数是近似相等的。
DirectXMath提供了XMVector3NearEqual函数，用于以Epsilon作为容差。
XMFINLINE bool XM_CALLCONV XMVector3NearEqual(FXMVECTOR U, FXMVECTOR V, FXMVECTOR Epsilon);

















