4.1 预备知识
4.1.1 Direct3D 12概述
通过Direct3D这种底层图形应用程序编程接口，即可在在应用程序中对图形处理器(GPU)进行控制和编程。
Direct3D 12较之上一个版本的主要改变在于其性能优化方面大大减少了在CPU开销的同时，又改进了对多线程的支持。

4.1.2 组件对象模型
组件对象模型(Component Object Model,COM)是一种令DirectX不受编程语言束缚，并且使之向后兼任的技术。
COM对象会统计引用次数，因此，在使用完某接口时，我们应调用它的Release方法。
而不是用delete来删除，当COM对象的引用技术为0，它将自行释放自己所占用的内存。
我们可以把Microsoft::WRL::ComPtr类(#include<wrl.h>)当做是COM对象的智能指针。
当一个Comptr实例超出作用域范围，它便会自动调用相应COM对象的Release方法，继而省掉了我们手动调用的麻烦。
常用的3个Comptr方法如下：
1，Get：返回一个指向底层COM接口的指针。此方法常用于把原始的COM接口指针作为参数传递给函数。
2，GetAddressOf:返回指向此底层COM接口指针的地址。
3，Reset：将此ComPtr实例设置为nullptr释放与之相关的所有引用。（同时减少其底层COM接口的引用计数）。
此方法的功能更与将ComPtr目标实例赋值为nullptr效果相同。

4.1.3 纹理格式
2D纹理是一种由数据元素构成的矩阵，可将此矩阵看作2D数组。
纹理中的每一个元素存储的都是一个像素的颜色。
然而纹理的用处并非仅此而已，法线贴图的纹理内每个元素存储的就是一个3D向量而不是颜色信息。
简单来讲，1D,2D,3D纹理就相当于特定数据元素所构成1D,2D,3D数组。
纹理其实还不只是像数据数组那样简单。它们可能还具有多种mipmap层级，而GPU则会据此对它们进行特殊的处理。例如运用过滤器和进行多重采样。
并不是任意类型的数据元素都能用于组成纹理，它只能存储DXGI_FORMAT枚举类型中描述的特定格式的数据元素。
1，DXGI_FORMAT_R32G32B32_FLOAT:每个元素由3个32位浮点数分量构成。
2，DXGI_FORMAT_R16G16B16A16_UNORM:由4个16位分量构成，每个分量被映射到[0,1]区间。
3，DXGI_FORMAT_R32G32_UINT:2个32位无符号整数分量够成
4，DXGI_FORMAT_R8G8B8A8_UNORM:4个8位无符号分量构成，每个分量被映射到[0,1]区间。
5，DXGI_FORMAT_R8G8B8A8_SNORM:每个分量被映射到[-1,1]
6，DXGI_FORMAT_R8G8B8A8_SINT:每个分量被映射到[-128,127]
7，DXGI_FORMAT_R8G8B8A8_UINT:每个分量被映射到[0,255]
DXGI_FORMAT_R16G16B16A16_TYPELESS无类型

4.14 交换链和页面翻转
为了避免动画中出现画面闪烁的现象，最好将动画帧完整地绘制在一种称为后台缓冲区的离屏纹理内。
为此需要利用由硬件管理的两种纹理缓冲区：前台缓冲区和后台缓冲区。
前台缓冲区存储的是当前显示在屏幕上的图像数据，而动画的下一帧则被绘制在后台缓冲区里。
当后台缓冲区中的动画帧绘制完成之后，两种缓冲区的角色互换。
前后台缓冲的这种互换操作称为呈现。
前台缓冲区和后台缓冲区构成了交换链，在Direct3D中用IDXGISwapChain接口表示。
使用两个缓冲区的情况称为双缓冲，也可以运用更多的缓冲区，比如三重缓冲区，一般两个缓冲区就足够了。

4.1.5 深度缓冲
深度缓冲区这种纹理资源存储的并非图像数据，而是特定像素的深度信息。
深度值得范围为0--1。0代表观察者在视椎体中能看到离自己最近的物体，1则表示视椎体内最远的物体。
深度缓冲区中的元素与后台缓冲区内的像素呈一一对应关系。即后台缓冲区中第i行第j列的元素对应于深度缓冲区内第i行第j列数据。
如果后台缓冲区的分辨率为1280x1024，那么深度缓冲区中就应当有1280x1024个深度元素。
为了确定不同物体间的像素前后顺序，Direct3D采用了一种叫做深度缓冲或z缓冲的技术。
若使用了深度缓冲，则物体的绘制顺序也就变得无关紧要了。
在开始渲染之前，后台缓冲区会被清理为默认颜色，深度缓冲区也将被清除为默认值-通常为1.0。
总而言之，深度缓冲技术的原理是计算每个像素的深度值，并执行深度测试。
深度缓冲区也是一种纹理，所以一定要用明确的数据格式来创建它。
深度缓冲区可用的格式：
1，DXGI_FORMAT_D32_FLOAT_S8X24_UINT：占用64位，取其中的32位制定一个浮点型深度缓冲区，另外8位无符号整数分配给模板缓冲区，并将该元素映射到[0,255]区间，剩下的24位仅用于填充对齐不作他用。
2，DXGI_FORMAT_D32_FLOAT：32位浮点型深度缓冲区。
3，DXGI_FORMAT_D24_UNORM_S8_UINT:指定一个无符号24位深度缓冲区，并将该元素映射到[0,1]区间。另外8位无符号数分配给模板缓冲区，元素映射到[0,255]
4，DXGI_FORMAT_D16_UNORM：无符号16位深度缓冲区，该元素映射到[0,1]区间。
一个应用程序不一定要用到模板缓冲区。但一经使用，则深度缓冲区将总是与模板缓冲区如影随形。

4.1.6 资源与描述符
在发出绘制命令之前，我们需要将与本次绘制调用（draw call）相关的资源绑定到渲染流水线上。
但是，GPU资源并非直接与渲染流水线相绑定，而是要通过一种名为描述符的对象来对它间接引用。
我们可以把描述符视为一种对送往GPU的资源进行描述的轻量级结构。
本质上来讲，它实际上即为一个中间层；若指定了资源描述符，GPU将机能获得实际的资源数据，也能了解到资源的必要信息。
因此，我们将把绘制调用需要引用的资源，通过指定描述符的方式绑定到渲染流水线。
为什么我们需要额外使用描述符这个中间层呢？因为GPU资源实质上都是一些普通的内存块。由于资源的这种通用性，它们便能被设置到渲染流水线的不同阶段供其使用。
视图和描述符是同义词。
每个描述符都有一种具体类型，此类型指明了资源的具体作用。本书常用的描述符如下：
1，CBV/SRV/UAV描述符分别表示的是常量缓冲区视图，着色器资源视图和无序访问视图这3种资源；
2，采样器描述符表示的是采样器资源（用于纹理贴图）。
3，RTV描述符表示的是渲染目标视图资源。
4，DSV描述符表示的是深度/模板视图资源。
描述符堆中存有一系列描述符，本质上是存放用户程序中某种特定类型描述符的一块内存。
我们需要为每一种类型的描述符都创建出单独的描述符堆。也可以为同一种描述符类型创建出多个描述符堆。
我们可以用多个描述符来引用同一个资源。
一个资源可以绑定到渲染流水线的不同阶段。因此，对于每个阶段都需要设置独立的描述符。
创建描述符的最佳时机为初始化期间。

4.1.7 多重采样技术的原理
由于屏幕中显示的像素不可能是无穷小的，所以并不是任意一条直线都能在显示器上平滑而完美地呈现出来。
在不能提升显示器分辨率或在显示器分辨率受限的情况下，我们就可以运用各种反走样（也有译为抗锯齿）技术。
有一种名为超级采样，可简记作SSAA的反走样技术。它使用4倍于屏幕分辨率大小的后台缓冲区和深度缓冲区。
当数据要从后台缓冲区调往屏幕显示的时候，会将后台缓冲区按4个像素一组进行解析。每组用求平均值的方法得到一种相对平滑的像素颜色。
超级采样实际上是通过软件的方式提升了画面的分辨率。
超级采样是一种开销昂贵的操作。Direct3D还支持一种在性能与效果等方面较为折中的反走样技术，称为多重采样，MSAA。
这种技术通过跨子像素共享一些计算信息，从而使它比超级采样的开销更低。
现假设采用4X多重采样（即每个像素中都有4个子像素），并同样使用4倍于屏幕分辨率的后台缓冲区和深度缓冲区。
值得注意的是，这种技术并不需要对每一个子像素都进行计算，而是仅计算一次像素中心处的颜色，再基于可见性和覆盖性将得到的颜色信息分享给其子像素。

4.1.8 利用Direct3D进行多重采样
typedef struct DXGI_SAMPLE_DESC{
	UINT Count;
	UINT Quality;
}DXGI_SAMPLE_DESC;
Count成员指定了每个像素的采样次数，Quality成员则用于指示用户期望的图像质量级别。
根据给定的纹理格式和采样数量，我们就能用ID3D12Device::CheckFeatureSupport方法查询到对应的质量级别。
每个像素最大采样数量被定义为：
#define D3D12_MAX_MULTISAMPLE_COUNT(32)
通常会把采样数量设定为4或8。如果不希望使用多重采样，则可将采样数量设为1，并令质量级别为0.
在创建交换链缓冲区和深度缓冲区时都需要填写DXGI_SAMPLE_DESC结构体。当创建后台缓冲区和深度缓冲区时，多重采样的有感设置一定要相同。

4.1.9 功能级别
在Direct3D开始便引进了功能级别的概念。
功能级别为不同级别所支持的功能进行了严格的界定，每个功能级别所支持的特定功能可参见SDK文档。
如果用户的硬件不支持某特定功能级别，应用程序理当回退至版本更低的功能级别。

4.1.10 DirectX图形基础结构
DirectX图形基础结构（DXGI）是一种与Direct3D配合使用的API。
设计DXGI的基本理念是是多种图形API中所共有的底层任务能借助一组通用API来进行处理。
下面介绍一些在Direct3D初始化时会用到的相关接口：
IDXGIFactory主要用于创建IDXGISwapChain接口以及枚举显示适配器。而显示适配器则真正实现了图形处理能力。
一个系统中可能会存在数个适配器（比如装有数块显卡），显示器用接口IDXGIAdapter来表示。
一个系统也可能装有数个显示设备，我们称每一台显示设备都是一个显示输出实例（适配器输出），用IDXGIOutput接口表示。
每种显示设备都有一系列它所支持的显示模式，可以用DXGI_MODE_DESC结构体中的数据成员表示。
在进入全屏模式之时，枚举显示模式就显得尤为重要。为了获得最优的全屏性能，我们所指定的显示模式一定要与显示器支持的显示模式完全匹配。
 
4.1.11 功能支持的检测
我们已经通过ID3D12Device::CheckFeatureSupport方法，检测了当前图形驱动对多重采样的支持。
然而，这只是此函数对功能支持检测的冰山一角。这个方法的原型见文档。

4.1.12 资源驻留
复杂的游戏会运用大量纹理和3D网格等资源，但是其中的大多数并不需要总是置于显存中供GPU使用。
在Direct3D 12中，应用程序通过控制资源在显存中的去留，主动管理资源的驻留情况。在Direct3D 11中由系统自动管理。
一般来说，资源在创建时就会驻留在显存中，而当它被销毁时则清出。但是通过下面方法，我们可以自己控制资源的驻留。

4.2 CPU与GPU间的交互
在进行图形编程时，我们一定要了解有两种处理器在参与处理工作：CPU和GPU。两者并行工作，但有时要同步。
为了获得最佳性能，最好情况是让两者尽量同时工作，少同步。
同步意味着有一种处理器要以空闲状态等待另一种处理器完成某些任务。

4.2.1 命令队列和命令列表
每个GPU都至少维护者一个命令队列，本质上是环形缓冲区。
借助Direct3D API,CPU可利用命令列表将命令提交到这个队列中去。
当一系列命令被提交至命令队列之时，它们并不会被GPU立即执行。新来的命令会在队列中等待执行。
加入命令队列空空如也，那么没有任务可执行的GPU只能空闲下来。
相反，如果命令队列被填满，那么CPU必将随着GPU的工作步伐在某些时刻保持空闲。这两种情况都是我们不希望看到的。
在Direct3D 12中，命令队列被抽象为ID3D12CommandQueue接口来表示。
要通过填写D3D12_COMMAND_QUEUE_DESC结构体来描述队列，在调用ID3D12Device::CreateCommandQueue方法创建队列。
IID_PPV_ARGS辅助函数的本质是将ppType强制转换为void**类型。
ExecuteCommandLists是一种常用的ID3D12CommandQueue接口方法，利用它可将命令列表中的命令添加到命令队列中。
ID3D12GraphicsCommandList接口封装了一系列图形渲染命令，该接口有数种方法向命令列表添加命令。
当命令都被加入命令列表之后，我们必须调用ID3D12GraphicsCommandList::Close方法来结束命令的记录。
还有一种与命令列表有关的名为ID3D12CommandAllocator的内存管理类接口。
记录在命令列表内的命令，实际上是存储在与之关联的命令分配器上。
当通过ID3D12CommandQueue::ExecuteCommandLists方法执行命令列表的时候，命令队列就会引用分配器里的命令。
而分配器由ID3D12Device接口来创建。ID3D12Device::CreateCommandAllocator。接口的参数详解见书本。
命令列表同样由ID3D12Device接口创建：ID3D12Device::CreateCommandList。接口的参数详解见书本。
可以通过ID3D12CommandList::GetNodeCount方法来查询系统中GPU适配器节点的数量。
我们可以创建出多个关联于同一命令分配器的命令列表，但是不能同时用它们记录命令。
因此，当其中的一个命令列表在记录命令时，必须关闭同一命令分配器的其他命令列表。
换句话说，要保证命令列表的所有命令都会按顺序连续地添加到命令分配器内。
当创建或重置一个命令列表的时候，它会处于一种打开的状态。所以，当尝试为同一个命令分配器连续创建两个命令列表时，我们会得到一个错误消息。
在调用ID3D12CommandQueue::ExecuteCommandLists方法之后，我们就可以通过ID3D12GraphicsCommandList::Reset方法，安全地复用命令列表c占用的相关底层来记录新的命令集。
ID3D12GraphicsCommandList::Reset方法将命令列表恢复为刚创建时的初始状态，我们可以借此继续复用其底层内存，避免释放旧列表再创建新列表这一系列繁琐操作。
向GPU提交了一整帧的渲染命令后，我们可能还要为了绘制下一帧而复用命令分配器中的内存。
ID3D12CommandAllocator::Reset()
由于命令队列可能会引用命令分配器中的数据，所以在没有确定GPU执行完命令分配器中的所有命令之前，千万不要重置命令分配器。

4.2.2 CPU与GPU间的同步
假设有一资源R，里面存有绘制几何体的位置信息。现在，令CPU对R中数据进行更新，先把R中的几何体位置信息改成p1，再向命令队列里添加绘制资源R的命令C。
在GPU执行绘制命令C之前，如果CPU率先覆写了数据R，修改位置信息为p2，会造成一个严重的错误。
解决此问题的一种方法是：强制CPU等待，知道GPU完成所有命令的处理，达到某个指定的围栏点为止。这种方法称为刷新命令队列。
围栏用ID3D12Fence接口来表示，此技术用于实现CPU和GPU的同步。

4.2.3 资源转换
为了实现常见的渲染效果，我们经常会通过GPU对某个资源R按顺序进行先写后读这两种操作。
然而，当GPU的写操作还没有完成抑或甚至还没有开始，却开始读取资源，便会导致资源冒险。
为此，Direct3D专门针对资源设计了一组相关状态。资源在创建伊始会处于默认状态。
如果要对某个资源执行写操作时，需要将它的状态转换为渲染目标状态；而要对该纹理进行读操作时，再把它的装填变为着色器资源状态。
通过命令列表设置转换资源屏幕数组，即可指定资源的转换；当我们希望以一次API调用来转换多个资源时，这种数组就派上用场了。
资源屏障用D3D12_RESOURCE_BARRIER结构体来表示。

4.2.4 命令与多线程
对于内含许多物体的庞大场景而言，仅通过一个构建命令列表来绘制整个场景会占用不少的CPU时间。
因此可以采用一种并行创建命令列表的思路。例如，我们可以创建4条线程，每条分别负责构件一个命令列表来绘制25%场景物体。
以下是一些在多线程环境中使用命令列表要注意的问题：
1，命令列表并非自由线程对象。也就是说，多线程既不能同时共享相同的命令列表，也不能同时调用同一命令类表的方法。所以，每个线程通常都只使用各自的命令列表。
2，命令分配器也不是线程自由的。每个线程都仅使用属于自己的命令分配器。
3，命令队列是线程自由的。多个线程可以同时访问同一命令队列，也能够同时调用它的方法。特别是每个线程都能同时向命令队列提交它们自己所生成的命令列表。
4，出于性能原因，应用程序必须在初始化期间，支出用于并行记录命令的命令列表最大数量。

4.3 初始化Direct3D
对Direct3D进行初始化的过程分为几个步骤：
1，用D3D12CreateDevice函数创建ID3D12Device接口实例；
2，创建一个ID3D12Fence对象，并查询描述符的大小；
3，检测用户设备对4X MSAA质量级别的支持情况；
4，依次创建命令队列，命令列表分配器和主命令列表；
5，描述并创建交换链；
6，创建应用程序所需的描述符堆；
7，调整后台缓冲区的大小，并为它创建渲染目标视图；
8，创建深度/模板缓冲区及与之关联的深度/模板视图；
9，设置视口和剪裁矩阵；

4.3.1 创建设备
要初始化Direct3D，必须先创建Direct3D 12设备(ID3D12Device)。此设备代表着一个显示适配器。一般来说，显示适配器是一种3D图形硬件（如显卡）。
但是一个系统也能用软件显示适配器来模拟3D图形硬件的功能。
通过D3D12CreateDevice接口可以创建Direct3D 12设备，参数详情见书本。

4.3.2 创建围栏并获取描述符的大小

4.3.3 检测对4X MSAA质量级别的支持

4.3.4 创建命令队列和命令列表
4.3.5 描述并创建交换链
首先要填写一份DXGI_SWAP_CHAIN_DESC结构体实例，用它描述欲创建交换链的特性。各参数含义见书本。















